import { TEditor, TNode, Value, TSelection, TElement, TText, TNodeEntry, NodeOf, TNodeProps, SetNodesOptions } from '@udecode/slate';
import * as slate from 'slate';
import { Path, Location, Point, Range } from 'slate';
import * as slate_dom from 'slate-dom';
import { DOMNode, DOMPoint, DOMRange } from 'slate-dom';
import { ReactEditor } from 'slate-react';
import React$1 from 'react';
import { UnknownObject } from '@udecode/utils';

/** Blur the editor. */
declare const blurEditor: (editor: TEditor) => void;

/** Deselect the editor. */
declare const deselectEditor: (editor: TEditor) => void;

/** Find the DOM node that implements DocumentOrShadowRoot for the editor. */
declare const findEditorDocumentOrShadowRoot: (editor: TEditor) => Document | ShadowRoot | undefined;

/** {@link ReactEditor.findEventRange} */
declare const findEventRange: (editor: TEditor, event: any) => slate.BaseRange | undefined;

/** Find a key for a Slate node. */
declare const findNodeKey: (editor: TEditor, node: TNode) => slate_dom.Key | undefined;

/** Find the path of Slate node. */
declare const findPath: (editor: TEditor, node: TNode) => Path | undefined;

/**
 * Focus the editor. Extension:
 *
 * If `target` is defined:
 *
 * - Deselect the editor (otherwise it will focus the start of the editor)
 * - Select the editor
 * - Focus the editor
 */
declare const focusEditor: (editor: TEditor, target?: Location) => void;

/** Return the host window of the current editor. */
declare const getEditorWindow: (editor: TEditor) => Window | undefined;

/** Check if a DOM node is within the editor. */
declare const hasEditorDOMNode: (editor: TEditor, target: DOMNode, options?: Parameters<typeof ReactEditor.hasDOMNode>[2]) => boolean;

/** Check if the target is editable and in the editor. */
declare const hasEditorEditableTarget: (editor: TEditor, target: EventTarget | null) => target is Node;

/** Check if the target can be selectable. */
declare const hasEditorSelectableTarget: (editor: TEditor, target: EventTarget | null) => boolean;

/** Check if the target is in the editor. */
declare const hasEditorTarget: (editor: TEditor, target: EventTarget | null) => target is Node;

/** Insert data from a `DataTransfer` into the editor. */
declare const insertData: (editor: TEditor, data: DataTransfer) => void;

/** Check if the user is currently composing inside the editor. */
declare const isComposing: (editor: TEditor) => boolean;

/** Check if the editor is focused. */
declare const isEditorFocused: (editor: TEditor) => boolean;

/** Check if the editor is in read-only mode. */
declare const isEditorReadOnly: (editor: TEditor) => boolean;

/** Check if the target is inside void and in an non-readonly editor. */
declare const isTargetInsideNonReadonlyVoid: (editor: TEditor, target: EventTarget | null) => boolean;

/** Sets data from the currently selected fragment on a `DataTransfer`. */
declare const setFragmentData: (editor: TEditor, data: DataTransfer) => void;

/** Find the native DOM element from a Slate node. */
declare const toDOMNode: (editor: TEditor, node: TNode) => HTMLElement | undefined;

/** Find a native DOM selection point from a Slate point. */
declare const toDOMPoint: (editor: TEditor, point: Point) => slate_dom.DOMPoint | undefined;

/** {@link ReactEditor.toDOMRange} */
declare const toDOMRange: (editor: TEditor, range: Range) => globalThis.Range | undefined;

/** {@link ReactEditor.toSlateNode} */
declare const toSlateNode: (editor: TEditor, domNode: DOMNode) => TNode | undefined;

/** {@link ReactEditor.toSlatePoint} */
declare const toSlatePoint: (editor: TEditor, domPoint: DOMPoint, options: Parameters<typeof ReactEditor.toSlatePoint>[2]) => slate.BasePoint | null | undefined;

/** {@link ReactEditor.toSlateRange} */
declare const toSlateRange: (editor: TEditor, domRange: Parameters<typeof ReactEditor.toSlateRange>[1], options: Parameters<typeof ReactEditor.toSlateRange>[2]) => slate.BaseRange | null | undefined;

interface SlateProps extends UnknownObject {
    children: React$1.ReactNode;
    editor: ReactEditor;
    initialValue: Value;
    onChange?: (value: Value) => void;
    onSelectionChange?: (selection: TSelection) => void;
    onValueChange?: (value: Value) => void;
}

interface TRenderElementProps<N extends TElement = TElement> {
    attributes: {
        'data-slate-node': 'element';
        ref: any;
        'data-slate-inline'?: true;
        'data-slate-void'?: true;
        dir?: 'rtl';
    };
    children: any;
    element: N;
}
type RenderElementFn = (props: TRenderElementProps) => React.ReactElement;

interface TRenderLeafProps<N extends TText = TText> {
    attributes: {
        'data-slate-leaf'?: true;
    };
    children: any;
    leaf: N;
    text: N;
}
type RenderLeafFn = (props: TRenderLeafProps) => React.ReactElement;

/** `EditableProps` are passed to the <Editable> component. */
type TEditableProps = {
    renderPlaceholder?: (props: {
        attributes: {
            contentEditable: boolean;
            'data-slate-placeholder': boolean;
            ref: React.RefCallback<any>;
            style: React.CSSProperties;
            dir?: 'rtl';
        };
        children: any;
    }) => JSX.Element;
    as?: React.ElementType;
    decorate?: (entry: TNodeEntry) => Range[];
    disableDefaultStyles?: boolean;
    placeholder?: string;
    readOnly?: boolean;
    renderElement?: RenderElementFn;
    renderLeaf?: RenderLeafFn;
    role?: string;
    scrollSelectionIntoView?: (editor: TEditor, domRange: DOMRange) => void;
    style?: React.CSSProperties;
    onDOMBeforeInput?: (event: InputEvent) => void;
} & React.TextareaHTMLAttributes<HTMLDivElement>;

/** Focus an editor edge. */
declare const focusEditorEdge: (editor: TEditor, { edge, }?: {
    edge?: "end" | "start";
}) => void;

declare const setNode: <N extends NodeOf<E>, E extends TEditor = TEditor>(editor: E, node: N, props: Partial<TNodeProps<N>>, options?: Omit<SetNodesOptions<E>, "at">) => void;

export { type RenderElementFn, type RenderLeafFn, type SlateProps, type TEditableProps, type TRenderElementProps, type TRenderLeafProps, blurEditor, deselectEditor, findEditorDocumentOrShadowRoot, findEventRange, findNodeKey, findPath, focusEditor, focusEditorEdge, getEditorWindow, hasEditorDOMNode, hasEditorEditableTarget, hasEditorSelectableTarget, hasEditorTarget, insertData, isComposing, isEditorFocused, isEditorReadOnly, isTargetInsideNonReadonlyVoid, setFragmentData, setNode, toDOMNode, toDOMPoint, toDOMRange, toSlateNode, toSlatePoint, toSlateRange };
