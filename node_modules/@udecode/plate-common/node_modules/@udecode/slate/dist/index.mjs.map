{"version":3,"sources":["../src/createTEditor.ts","../src/interfaces/editor/addMark.ts","../src/interfaces/editor/createPathRef.ts","../src/interfaces/editor/createPointRef.ts","../src/interfaces/editor/createRangeRef.ts","../src/interfaces/editor/deleteBackward.ts","../src/interfaces/editor/deleteForward.ts","../src/interfaces/editor/deleteFragment.ts","../src/interfaces/editor/deleteMerge.ts","../src/interfaces/transforms/mergeNodes.ts","../src/interfaces/editor/getAboveNode.ts","../src/interfaces/editor/isBlock.ts","../src/interfaces/element/elementMatches.ts","../src/interfaces/element/isElement.ts","../src/interfaces/element/isElementList.ts","../src/utils/match.ts","../src/interfaces/editor/getNodeEntries.ts","../src/interfaces/editor/unhangRange.ts","../src/interfaces/editor/getParentNode.ts","../src/interfaces/editor/getPreviousNode.ts","../src/interfaces/editor/isElementEmpty.ts","../src/interfaces/editor/withoutNormalizing.ts","../src/interfaces/text/isText.ts","../src/interfaces/node/hasSingleChild.ts","../src/interfaces/transforms/deleteText.ts","../src/interfaces/transforms/moveNodes.ts","../src/interfaces/transforms/removeNodes.ts","../src/interfaces/transforms/select.ts","../src/interfaces/editor/getEndPoint.ts","../src/interfaces/editor/getLeafNode.ts","../src/interfaces/editor/getPointAfter.ts","../src/interfaces/editor/getPointBefore.ts","../src/interfaces/editor/getStartPoint.ts","../src/interfaces/editor/getVoidNode.ts","../src/interfaces/editor/isVoid.ts","../src/interfaces/editor/getEdgePoints.ts","../src/interfaces/editor/getEditorString.ts","../src/interfaces/editor/getFirstNode.ts","../src/interfaces/editor/getFragment.ts","../src/interfaces/editor/getLastNode.ts","../src/interfaces/editor/getLevels.ts","../src/interfaces/editor/getMarks.ts","../src/interfaces/editor/getNextNode.ts","../src/interfaces/editor/getNodeEntry.ts","../src/interfaces/editor/getPath.ts","../src/interfaces/editor/getPathRefs.ts","../src/interfaces/editor/getPoint.ts","../src/interfaces/editor/getPointRefs.ts","../src/interfaces/editor/getPositions.ts","../src/interfaces/editor/getRange.ts","../src/interfaces/editor/getRangeRefs.ts","../src/interfaces/editor/hasBlocks.ts","../src/interfaces/editor/hasInlines.ts","../src/interfaces/editor/hasTexts.ts","../src/interfaces/editor/insertBreak.ts","../src/interfaces/editor/insertNode.ts","../src/interfaces/editor/isEdgePoint.ts","../src/interfaces/editor/isEditor.ts","../src/interfaces/editor/isEditorNormalizing.ts","../src/interfaces/editor/isEndPoint.ts","../src/interfaces/editor/isInline.ts","../src/interfaces/editor/isMarkableVoid.ts","../src/interfaces/editor/isStartPoint.ts","../src/interfaces/editor/normalizeEditor.ts","../src/interfaces/editor/removeEditorMark.ts","../src/slate-history/history-editor.ts","../src/slate-history/history.ts","../src/slate-history/with-history.ts","../src/interfaces/history-editor/isHistoryEditor.ts","../src/interfaces/history-editor/isHistoryMerging.ts","../src/interfaces/history-editor/isHistorySaving.ts","../src/interfaces/history-editor/withMerging.ts","../src/interfaces/history-editor/withNewBatch.ts","../src/interfaces/history-editor/withoutMergingHistory.ts","../src/interfaces/history-editor/withoutSavingHistory.ts","../src/interfaces/node/TDescendant.ts","../src/interfaces/node/getCommonNode.ts","../src/interfaces/text/isTextList.ts","../src/interfaces/text/textEquals.ts","../src/interfaces/text/textMatches.ts","../src/interfaces/node/getNode.ts","../src/interfaces/node/getNodeAncestor.ts","../src/interfaces/node/getNodeAncestors.ts","../src/interfaces/node/getNodeChild.ts","../src/interfaces/node/getNodeChildren.ts","../src/interfaces/node/getNodeDescendant.ts","../src/interfaces/node/getNodeDescendants.ts","../src/interfaces/node/getNodeElements.ts","../src/interfaces/node/getNodeFirstNode.ts","../src/interfaces/node/getNodeFragment.ts","../src/interfaces/node/getNodeLastNode.ts","../src/interfaces/node/getNodeLeaf.ts","../src/interfaces/node/getNodeLevels.ts","../src/interfaces/node/getNodeParent.ts","../src/interfaces/node/getNodeProps.ts","../src/interfaces/node/getNodeString.ts","../src/interfaces/node/getNodeTexts.ts","../src/interfaces/node/getNodes.ts","../src/interfaces/node/hasNode.ts","../src/interfaces/node/isAncestor.ts","../src/interfaces/node/isNode.ts","../src/interfaces/node/isNodeList.ts","../src/interfaces/node/nodeMatches.ts","../src/interfaces/range/isCollapsed.ts","../src/interfaces/range/isExpanded.ts","../src/interfaces/transforms/collapseSelection.ts","../src/interfaces/transforms/deselect.ts","../src/interfaces/transforms/insertFragment.ts","../src/interfaces/transforms/insertNodes.ts","../src/utils/queryNode.ts","../src/interfaces/transforms/insertText.ts","../src/interfaces/transforms/liftNodes.ts","../src/interfaces/transforms/moveSelection.ts","../src/interfaces/transforms/setNodes.ts","../src/interfaces/transforms/setPoint.ts","../src/interfaces/transforms/setSelection.ts","../src/interfaces/transforms/splitNodes.ts","../src/interfaces/transforms/unsetNodes.ts","../src/interfaces/transforms/unwrapNodes.ts","../src/interfaces/transforms/wrapNodes.ts","../src/queries/findNode.ts","../src/queries/findNodePath.ts","../src/queries/someNode.ts","../src/transforms/addRangeMarks.ts","../src/transforms/setElements.ts","../src/transforms/setNode.ts","../src/transforms/unhangCharacterRange.ts"],"sourcesContent":["import { createEditor } from 'slate';\n\nimport type { TEditor, Value } from './interfaces/editor/TEditor';\n\nconst noop: {\n  (name: string): () => void;\n  <T>(name: string, returnValue: T): () => T;\n} =\n  <T>(name: string, returnValue?: T) =>\n  () => {\n    console.warn(\n      `[OVERRIDE_MISSING] The method editor.${name}() has not been implemented or overridden. ` +\n        `This may cause unexpected behavior. Please ensure that all required editor methods are properly defined.`\n    );\n\n    return returnValue;\n  };\n\nexport const createTEditor = <V extends Value>() => {\n  const editor = createEditor() as any as TEditor<V>;\n\n  // slate-react\n  editor.hasEditableTarget = noop('hasEditableTarget', false) as any;\n  editor.hasRange = noop('hasRange', false);\n  editor.hasSelectableTarget = noop('hasSelectableTarget', false);\n  editor.hasTarget = noop('hasTarget', false) as any;\n  editor.insertData = noop('insertData');\n  editor.insertFragmentData = noop('insertFragmentData') as any;\n  editor.insertTextData = noop('insertTextData', false);\n  editor.isTargetInsideNonReadonlyVoid = noop(\n    'isTargetInsideNonReadonlyVoid',\n    false\n  );\n  editor.setFragmentData = noop('setFragmentData');\n\n  // slate-history\n  editor.history = { redos: [], undos: [] };\n  editor.undo = noop('undo');\n  editor.redo = noop('redo');\n  editor.writeHistory = noop('writeHistory');\n\n  return editor;\n};\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/**\n * Add a custom property to the leaf text nodes in the current selection.\n *\n * If the selection is currently collapsed, the marks will be added to the\n * `editor.marks` property instead, and applied when text is inserted next.\n */\nexport const addMark = (editor: TEditor, key: string, value: any) =>\n  Editor.addMark(editor as any, key, value);\n","import type { EditorPathRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { type Path, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/**\n * Create a mutable ref for a `Path` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createPathRef = (\n  editor: TEditor,\n  at: Path,\n  options?: EditorPathRefOptions\n) => Editor.pathRef(editor as any, at, options as any);\n","import type { EditorPointRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { type Point, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/**\n * Create a mutable ref for a `Point` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createPointRef = (\n  editor: TEditor,\n  point: Point,\n  options?: EditorPointRefOptions\n) => Editor.pointRef(editor as any, point, options as any);\n","import type { EditorRangeRefOptions } from 'slate/dist/interfaces/editor';\n\nimport { type Range, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/**\n * Create a mutable ref for a `Range` object, which will stay in sync as new\n * operations are applied to the editor.\n */\nexport const createRangeRef = (\n  editor: TEditor,\n  range: Range,\n  options?: EditorRangeRefOptions\n) => Editor.rangeRef(editor as any, range, options as any);\n","import type { EditorDirectedDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Delete content in the editor backward from the current selection. */\nexport const deleteBackward = (\n  editor: TEditor,\n  options?: EditorDirectedDeletionOptions\n) => Editor.deleteBackward(editor as any, options);\n","import type { EditorDirectedDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Delete content in the editor forward from the current selection. */\nexport const deleteForward = (\n  editor: TEditor,\n  options?: EditorDirectedDeletionOptions\n) => Editor.deleteForward(editor as any, options);\n","import type { EditorFragmentDeletionOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Delete the content in the current selection. */\nexport const deleteFragment = (\n  editor: TEditor,\n  options?: EditorFragmentDeletionOptions\n) => Editor.deleteFragment(editor as any, options);\n","import { type Location, Editor, Path, Point, Range } from 'slate';\n\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\nimport { mergeNodes } from '../transforms/mergeNodes';\nimport { removeNodes } from '../transforms/removeNodes';\nimport { select } from '../transforms/select';\nimport { createPathRef } from './createPathRef';\nimport { createPointRef } from './createPointRef';\nimport { getAboveNode } from './getAboveNode';\nimport { getEndPoint } from './getEndPoint';\nimport { getLeafNode } from './getLeafNode';\nimport { getNodeEntries } from './getNodeEntries';\nimport { getPointAfter } from './getPointAfter';\nimport { getPointBefore } from './getPointBefore';\nimport { getStartPoint } from './getStartPoint';\nimport { getVoidNode } from './getVoidNode';\nimport { isBlock } from './isBlock';\nimport { isVoid } from './isVoid';\nimport { withoutNormalizing } from './withoutNormalizing';\n\nexport const deleteMerge = (\n  editor: TEditor,\n  options: {\n    at?: Location;\n    distance?: number;\n    hanging?: boolean;\n    reverse?: boolean;\n    test?: any;\n    unit?: 'block' | 'character' | 'line' | 'word';\n    voids?: boolean;\n  } = {}\n): void => {\n  withoutNormalizing(editor as any, () => {\n    const {\n      distance = 1,\n      reverse = false,\n      unit = 'character',\n      voids = false,\n    } = options;\n    let { at = editor.selection, hanging = false } = options;\n\n    if (!at) {\n      return;\n    }\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      at = at.anchor;\n    }\n    if (Point.isPoint(at)) {\n      const furthestVoid = getVoidNode(editor as any, { at, mode: 'highest' });\n\n      if (!voids && furthestVoid) {\n        const [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        const opts = { distance, unit };\n        const target = reverse\n          ? getPointBefore(editor as any, at, opts) ||\n            getStartPoint(editor as any, [])\n          : getPointAfter(editor as any, at, opts) ||\n            getEndPoint(editor as any, []);\n        at = { anchor: at, focus: target };\n        hanging = true;\n      }\n    }\n    if (Path.isPath(at)) {\n      removeNodes(editor, { at, voids });\n\n      return;\n    }\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n    if (!hanging) {\n      at = Editor.unhangRange(editor as any, at, { voids });\n    }\n\n    let [start, end] = Range.edges(at);\n    const startBlock = getAboveNode(editor, {\n      at: start,\n      match: (n) => isBlock(editor as any, n),\n      voids,\n    });\n    const endBlock = getAboveNode(editor, {\n      at: end,\n      match: (n) => isBlock(editor as any, n),\n      voids,\n    });\n    const isAcrossBlocks =\n      startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    const isSingleText = Path.equals(start.path, end.path);\n    const startVoid = voids\n      ? null\n      : getVoidNode(editor as any, { at: start, mode: 'highest' });\n    const endVoid = voids\n      ? null\n      : getVoidNode(editor as any, { at: end, mode: 'highest' });\n\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startVoid) {\n      const before = getPointBefore(editor as any, start);\n\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n    if (endVoid) {\n      const after = getPointAfter(editor as any, end);\n\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    const matches: TNodeEntry[] = [];\n    let lastPath: Path | undefined;\n\n    const _nodes = getNodeEntries(editor as any, { at, voids });\n\n    for (const entry of _nodes) {\n      const [node, path] = entry;\n\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue;\n      }\n      if (\n        (!voids && isVoid(editor as any, node)) ||\n        (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n      ) {\n        matches.push(entry as any);\n        lastPath = path;\n      }\n    }\n\n    const pathRefs = Array.from(matches, ([, p]) =>\n      createPathRef(editor as any, p)\n    );\n    const startRef = createPointRef(editor as any, start);\n    const endRef = createPointRef(editor as any, end);\n\n    if (!isSingleText && !startVoid) {\n      const point = startRef.current!;\n      const [node] = getLeafNode(editor as any, point);\n      const { path } = point;\n      const { offset } = start;\n      const text = node.text.slice(offset);\n      editor.apply({ offset, path, text, type: 'remove_text' });\n    }\n\n    for (const pathRef of pathRefs) {\n      const path = pathRef.unref()!;\n      removeNodes(editor, { at: path, voids });\n    }\n\n    if (!endVoid) {\n      const point = endRef.current!;\n      const [node] = getLeafNode(editor as any, point);\n      const { path } = point;\n      const offset = isSingleText ? start.offset : 0;\n      const text = node.text.slice(offset, end.offset);\n      editor.apply({ offset, path, text, type: 'remove_text' });\n    }\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      // DIFF: allow custom mergeNodes\n      mergeNodes(editor as any, {\n        at: endRef.current,\n        hanging: true,\n        voids,\n      });\n    }\n\n    const point = endRef.unref() || startRef.unref();\n\n    if (options.at == null && point) {\n      select(editor as any, point);\n    }\n  });\n};\n","import type { Modify } from '@udecode/utils';\n\nimport {\n  type Element,\n  type Text,\n  type Transforms,\n  Editor,\n  Path,\n  Range,\n} from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor } from '../editor/TEditor';\n\nimport { createPathRef } from '../editor/createPathRef';\nimport { createPointRef } from '../editor/createPointRef';\nimport { getAboveNode } from '../editor/getAboveNode';\nimport { getNodeEntries } from '../editor/getNodeEntries';\nimport { getParentNode } from '../editor/getParentNode';\nimport { getPreviousNode } from '../editor/getPreviousNode';\nimport { isBlock } from '../editor/isBlock';\nimport { isElementEmpty } from '../editor/isElementEmpty';\nimport { withoutNormalizing } from '../editor/withoutNormalizing';\nimport { isElement } from '../element/isElement';\nimport { hasSingleChild } from '../node/hasSingleChild';\nimport { isText } from '../text/isText';\nimport { deleteText } from './deleteText';\nimport { moveNodes } from './moveNodes';\nimport { removeNodes } from './removeNodes';\nimport { select } from './select';\n\nexport type MergeNodesOptions<E extends TEditor = TEditor> = {\n  /**\n   * Default: if the node isn't already the next sibling of the previous node,\n   * move it so that it is before merging.\n   */\n  mergeNode?: (editor: E, options: { at: Path; to: Path }) => void;\n\n  /**\n   * Default: if there was going to be an empty ancestor of the node that was\n   * merged, we remove it from the tree.\n   */\n  removeEmptyAncestor?: (editor: E, options: { at: Path }) => void;\n} & Modify<\n  NonNullable<Parameters<typeof Transforms.mergeNodes>[1]>,\n  NodeMatchOption<E>\n>;\n\n/**\n * Merge a node at a location with the previous node of the same depth, removing\n * any empty containing nodes after the merge if necessary.\n */\nexport const mergeNodes = <E extends TEditor>(\n  editor: E,\n  options: MergeNodesOptions<E> = {}\n): void => {\n  withoutNormalizing(editor as any, () => {\n    let { at = editor.selection, match } = options;\n    const {\n      hanging = false,\n      mergeNode,\n      mode = 'lowest',\n      removeEmptyAncestor,\n      voids = false,\n    } = options;\n\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = getParentNode(editor, at)!;\n        match = (n) => parent.children.includes(n as any);\n      } else {\n        match = (n) => isBlock(editor as any, n);\n      }\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor as any, at);\n    }\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        const [, end] = Range.edges(at);\n        const pointRef = createPointRef(editor as any, end);\n        deleteText(editor, { at });\n        at = pointRef.unref()!;\n\n        if (options.at == null) {\n          select(editor as any, at);\n        }\n      }\n    }\n\n    const _nodes = getNodeEntries(editor as any, { at, match, mode, voids });\n    const [current] = Array.from(_nodes);\n    const prev = getPreviousNode(editor as any, { at, match, mode, voids });\n\n    if (!current || !prev) {\n      return;\n    }\n\n    const [node, path] = current;\n    const [prevNode, prevPath] = prev;\n\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n\n    const newPath = Path.next(prevPath);\n    const commonPath = Path.common(path, prevPath);\n    const isPreviousSibling = Path.isSibling(path, prevPath);\n    const _levels = Editor.levels(editor as any, { at: path });\n    const levels = new Set(\n      Array.from(_levels, ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n    );\n\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    const emptyAncestor = getAboveNode(editor as any, {\n      at: path,\n      match: (n) => levels.has(n) && isElement(n) && hasSingleChild(n),\n      mode: 'highest',\n    });\n\n    const emptyRef =\n      emptyAncestor && createPathRef(editor as any, emptyAncestor[1]);\n    let properties;\n    let position;\n\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (isText(node) && isText(prevNode)) {\n      const { text, ...rest } = node;\n      position = prevNode.text.length;\n      properties = rest as Partial<Text>;\n    } else if (isElement(node) && isElement(prevNode)) {\n      const { children, ...rest } = node;\n      position = prevNode.children.length;\n      properties = rest as Partial<Element>;\n    } else {\n      throw new Error(\n        `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n          node\n        )} ${JSON.stringify(prevNode)}`\n      );\n    }\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (\n      !isPreviousSibling && // DIFF\n      !mergeNode\n    ) {\n      moveNodes(editor, { at: path, to: newPath, voids });\n    }\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      // DIFF: start\n      if (removeEmptyAncestor) {\n        const emptyPath = emptyRef.current;\n        emptyPath && removeEmptyAncestor(editor as any, { at: emptyPath });\n      } else {\n        removeNodes(editor, { at: emptyRef.current!, voids });\n      }\n      // DIFF: end\n    }\n    // If the target node that we're merging with is empty, remove it instead\n    // of merging the two. This is a common rich text editor behavior to\n    // prevent losing formatting when deleting entire nodes when you have a\n    // hanging selection.\n    // DIFF: start\n    if (mergeNode) {\n      mergeNode(editor as any, { at: path, to: newPath });\n      // DIFF: end\n    } else if (\n      (isElement(prevNode) && isElementEmpty(editor as any, prevNode)) ||\n      (isText(prevNode) && prevNode.text === '')\n    ) {\n      removeNodes(editor, { at: prevPath, voids });\n    } else {\n      editor.apply({\n        path: newPath,\n        position,\n        properties,\n        type: 'merge_node',\n      });\n    }\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n","import type { Modify } from '@udecode/utils';\nimport type { EditorAboveOptions } from 'slate/dist/interfaces/editor';\n\nimport { Editor } from 'slate';\n\nimport type { AncestorOf, TAncestor } from '../node/TAncestor';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\nimport { type ENodeMatchOptions, getQueryOptions } from '../../utils/match';\n\nexport type GetAboveNodeOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<EditorAboveOptions<TAncestor>>,\n  ENodeMatchOptions<E>\n>;\n\n/** Get the ancestor above a location in the document. */\nexport const getAboveNode = <\n  N extends AncestorOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  options?: GetAboveNodeOptions<E>\n): TNodeEntry<N> | undefined =>\n  Editor.above(editor as any, getQueryOptions(editor, options)) as any;\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\nimport { isElement } from '../element';\n\n/** Check if a value is a block `Element` object. */\nexport const isBlock = (editor: TEditor, value: any): boolean =>\n  isElement(value) && Editor.isBlock(editor as any, value);\n","import { Element } from 'slate';\n\nimport type { TElement } from './TElement';\n\n/**\n * Check if an element matches set of properties.\n *\n * Note: this checks custom properties, and it does not ensure that any children\n * are equivalent.\n */\nexport const elementMatches = (element: TElement, props: object) =>\n  Element.matches(element, props);\n","import { Element } from 'slate';\n\nimport type { TElement } from './TElement';\n\n/** Check if a value implements the 'Element' interface. */\nexport const isElement = (value: any): value is TElement =>\n  Element.isElement(value);\n","import { Element } from 'slate';\n\nimport type { TElement } from './TElement';\n\n/** Check if a value is an array of `Element` objects. */\nexport const isElementList = (value: any): value is TElement[] =>\n  Element.isElementList(value);\n","import type { TEditor } from '../interfaces/editor/TEditor';\nimport type { NodeOf, TNode } from '../interfaces/node/TNode';\nimport type { TPath } from '../types/interfaces';\n\nimport { isBlock } from '../interfaces/editor/isBlock';\n\nexport type PredicateObj = Record<string, any[] | any>;\n\nexport type PredicateFn<T extends TNode> = (obj: T, path: TPath) => boolean;\n\nexport type Predicate<T extends TNode> = PredicateFn<T> | PredicateObj;\n\nfunction castArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Match the object with a predicate object or function. If predicate is:\n *\n * - Object: every predicate key/value should be in obj.\n * - Function: it should return true.\n */\nexport const match = <T extends TNode>(\n  obj: T,\n  path: TPath,\n  predicate?: Predicate<T>\n): boolean => {\n  if (!predicate) return true;\n  if (typeof predicate === 'object') {\n    return Object.entries(predicate).every(([key, value]) => {\n      const values = castArray<any>(value);\n\n      return values.includes(obj[key]);\n    });\n  }\n\n  return predicate(obj, path);\n};\n\n/**\n * Extended query options for slate queries:\n *\n * - `match` can be an object predicate where one of the values should include the\n *   node value. Example: { type: ['1', '2'] } will match the nodes having one\n *   of these 2 types.\n */\nexport const getQueryOptions = <E extends TEditor>(\n  editor: E,\n  options: any = {}\n) => {\n  const { block, match: _match } = options;\n\n  return {\n    ...options,\n    match:\n      _match || block\n        ? (n: NodeOf<E>, path: TPath) =>\n            match(n, path, _match) && (!block || isBlock(editor, n))\n        : undefined,\n  };\n};\n\nexport type ENodeMatch<N extends TNode> = Predicate<N>;\n\nexport interface ENodeMatchOptions<E extends TEditor = TEditor> {\n  block?: boolean;\n  match?: ENodeMatch<NodeOf<E>>;\n}\n","import type { Modify } from '@udecode/utils';\n\nimport { type EditorNodesOptions, Editor } from 'slate';\n\nimport type { NodeOf, TNode } from '../node/TNode';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\nimport { type ENodeMatchOptions, getQueryOptions } from '../../utils/match';\nimport { type UnhangRangeOptions, unhangRange } from './unhangRange';\n\nexport type GetNodeEntriesOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<EditorNodesOptions<TNode>>,\n  ENodeMatchOptions<E>\n> &\n  UnhangRangeOptions;\n\n/** Iterate through all of the nodes in the Editor. */\nexport const getNodeEntries = <\n  N extends NodeOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  options?: GetNodeEntriesOptions<E>\n): Generator<TNodeEntry<N>, void, undefined> => {\n  unhangRange(editor, options?.at, options);\n\n  return Editor.nodes(editor as any, getQueryOptions(editor, options)) as any;\n};\n","import {\n  type EditorUnhangRangeOptions,\n  type Path,\n  type Point,\n  type Span,\n  Editor,\n  Range,\n} from 'slate';\n\nimport type { TEditor } from './TEditor';\n\nexport type UnhangRangeOptions = {\n  unhang?: boolean;\n} & EditorUnhangRangeOptions;\n\n/**\n * Convert a range into a non-hanging one if:\n *\n * - `unhang` is true,\n * - `at` (default: selection) is a range.\n */\nexport const unhangRange = <\n  E extends TEditor,\n  R extends Path | Point | Range | Span | null | undefined,\n>(\n  editor: E,\n  range: R,\n  options: UnhangRangeOptions = {}\n): R => {\n  const { unhang = true, voids } = options;\n\n  if (Range.isRange(range) && unhang) {\n    return Editor.unhangRange(editor as any, range, { voids }) as R;\n  }\n\n  return range;\n};\n","import { type EditorParentOptions, type Location, Editor } from 'slate';\n\nimport type { AncestorOf } from '../node/TAncestor';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\n/** Get the parent node of a location. Returns undefined if there is no parent. */\nexport const getParentNode = <\n  N extends AncestorOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  at: Location,\n  options?: EditorParentOptions\n): TNodeEntry<N> | undefined => {\n  try {\n    return Editor.parent(editor as any, at, options) as any;\n  } catch (error) {}\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { type EditorPreviousOptions, Editor } from 'slate';\n\nimport type { NodeOf, TNode, TNodeMatch } from '../node/TNode';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\nexport type GetPreviousNodeOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<EditorPreviousOptions<TNode>>,\n  {\n    match?: TNodeMatch<NodeOf<E>>;\n  }\n>;\n\n/** Get the matching node in the branch of the document before a location. */\nexport const getPreviousNode = <\n  N extends NodeOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  options?: GetPreviousNodeOptions<E>\n): TNodeEntry<N> | undefined =>\n  Editor.previous(editor as any, options as any) as any;\n","import { Editor } from 'slate';\n\nimport type { TElement } from '../element/TElement';\nimport type { TEditor } from './TEditor';\n\n/** Check if an element is empty, accounting for void nodes. */\nexport const isElementEmpty = (editor: TEditor, element: TElement) =>\n  Editor.isEmpty(editor as any, element);\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/**\n * Call a function, deferring normalization until after it completes\n *\n * @returns True if normalized.\n */\nexport const withoutNormalizing = (\n  editor: TEditor,\n  fn: () => boolean | void\n) => {\n  let normalized = false;\n\n  Editor.withoutNormalizing(editor as any, () => {\n    normalized = !!fn();\n  });\n\n  return normalized;\n};\n","import { Text } from 'slate';\n\nimport type { TText } from './TText';\n\n/** Check if a value implements the `Text` interface. */\nexport const isText = (value: any): value is TText => Text.isText(value);\n","import type { TNode } from './TNode';\n\nimport { isText } from '../text/isText';\n\nexport const hasSingleChild = <N extends TNode>(node: N): boolean => {\n  if (isText(node)) {\n    return true;\n  }\n\n  return node.children.length === 1 && hasSingleChild(node.children[0]);\n};\n","import type { TextDeleteOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor } from '../editor/TEditor';\n\n/** Delete content in the editor. */\nexport const deleteText = (editor: TEditor, options?: TextDeleteOptions) => {\n  Transforms.delete(editor as any, options);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor } from '../editor/TEditor';\n\nexport type MoveNodesOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<Parameters<typeof Transforms.moveNodes>[1]>,\n  NodeMatchOption<E>\n>;\n\n/** Move the nodes at a location to a new location. */\nexport const moveNodes = <E extends TEditor>(\n  editor: E,\n  options?: MoveNodesOptions<E>\n) => Transforms.moveNodes(editor as any, options as any);\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor } from '../editor/TEditor';\n\nexport type RemoveNodesOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<Parameters<typeof Transforms.removeNodes>[1]>,\n  NodeMatchOption<E>\n>;\n\n/** Remove the nodes at a specific location in the document. */\nexport const removeNodes = <E extends TEditor>(\n  editor: E,\n  options?: RemoveNodesOptions<E>\n) => Transforms.removeNodes(editor as any, options as any);\n","import { type Location, Transforms } from 'slate';\n\nimport type { TEditor } from '../editor/TEditor';\n\n/** Set the selection to a new value. */\nexport const select = (editor: TEditor, target: Location) => {\n  Transforms.select(editor as any, target);\n};\n","import { type Location, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Get the end point of a location. */\nexport const getEndPoint = (editor: TEditor, at: Location) =>\n  Editor.end(editor as any, at);\n","import type { EditorLeafOptions } from 'slate/dist/interfaces/editor';\n\nimport { type Location, Editor } from 'slate';\n\nimport type { TextEntryOf } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\n/** Get the leaf text node at a location. */\nexport const getLeafNode = <E extends TEditor>(\n  editor: E,\n  at: Location,\n  options?: EditorLeafOptions\n): TextEntryOf<E> => Editor.leaf(editor as any, at, options) as any;\n","import { type EditorAfterOptions, type Location, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Get the point after a location. */\nexport const getPointAfter = (\n  editor: TEditor,\n  at: Location,\n  options?: EditorAfterOptions\n) => Editor.after(editor as any, at, options);\n","import { type EditorBeforeOptions, type Location, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Get the point before a location. */\nexport const getPointBefore = (\n  editor: TEditor,\n  at: Location,\n  options?: EditorBeforeOptions\n) => Editor.before(editor as any, at, options);\n","import { type Location, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Get the start point of a location. */\nexport const getStartPoint = (editor: TEditor, at: Location) =>\n  Editor.start(editor as any, at);\n","import { type EditorVoidOptions, Editor } from 'slate';\n\nimport type { ElementOf } from '../element/TElement';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\n/** Match a void node in the current branch of the editor. */\nexport const getVoidNode = <\n  N extends ElementOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  options?: EditorVoidOptions\n): TNodeEntry<N> | undefined => Editor.void(editor as any, options) as any;\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\nimport { isElement } from '../element';\n\n/** Check if a value is a void `Element` object. */\nexport const isVoid = (editor: TEditor, value: any): boolean => {\n  return isElement(value) && Editor.isVoid(editor as any, value);\n};\n","import { type Location, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Get the start and end points of a location. */\nexport const getEdgePoints = (editor: TEditor, at: Location) =>\n  Editor.edges(editor as any, at);\n","import type { EditorStringOptions } from 'slate/dist/interfaces/editor';\n\nimport { type Location, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/**\n * Get the text string content of a location.\n *\n * Note: by default the text of void nodes is considered to be an empty string,\n * regardless of content, unless you pass in true for the voids option\n */\nexport const getEditorString = (\n  editor: TEditor,\n  at: Location | null | undefined,\n  options?: EditorStringOptions\n) => {\n  if (!at) return '';\n\n  try {\n    return Editor.string(editor as any, at, options);\n  } catch {\n    return '';\n  }\n};\n","import { type Location, Editor } from 'slate';\n\nimport type { NodeEntryOf } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\n/** Get the first node at a location. */\nexport const getFirstNode = <E extends TEditor>(\n  editor: E,\n  at: Location\n): NodeEntryOf<E> => Editor.first(editor as any, at) as any;\n","import { type Location, Editor } from 'slate';\n\nimport type { ElementOrTextOf } from '../element/TElement';\nimport type { TEditor } from './TEditor';\n\n/** Get the fragment at a location. */\nexport const getFragment = <E extends TEditor>(\n  editor: E,\n  at: Location\n): ElementOrTextOf<E>[] => Editor.fragment(editor as any, at) as any;\n","import { type Location, Editor } from 'slate';\n\nimport type { NodeEntryOf } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\n/** Get the last node at a location. */\nexport const getLastNode = <E extends TEditor>(\n  editor: E,\n  at: Location\n): NodeEntryOf<E> => Editor.last(editor as any, at) as any;\n","import type { Modify } from '@udecode/utils';\n\nimport { type EditorLevelsOptions, Editor } from 'slate';\n\nimport type { NodeOf, TNode, TNodeMatch } from '../node/TNode';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\nexport type GetLevelsOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<EditorLevelsOptions<TNode>>,\n  {\n    match?: TNodeMatch<NodeOf<E>>;\n  }\n>;\n\n/** Iterate through all of the levels at a location. */\nexport const getLevels = <N extends NodeOf<E>, E extends TEditor = TEditor>(\n  editor: E,\n  options?: GetLevelsOptions<E>\n): Generator<TNodeEntry<N>, void, undefined> =>\n  Editor.levels(editor as any, options as any) as any;\n","import { Editor } from 'slate';\n\nimport type { MarksOf } from '../text/TText';\nimport type { TEditor } from './TEditor';\n\n/** Get the marks that would be added to text at the current selection. */\nexport const getMarks = <E extends TEditor>(editor: E) =>\n  Editor.marks(editor as any) as MarksOf<E> | null;\n","import type { Modify } from '@udecode/utils';\n\nimport { type EditorNextOptions, Editor } from 'slate';\n\nimport type { TDescendant } from '../node';\nimport type { NodeOf, TNodeMatch } from '../node/TNode';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\nexport type GetNextNodeOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<EditorNextOptions<TDescendant>>,\n  {\n    match?: TNodeMatch<NodeOf<E>>;\n  }\n>;\n\n/** Get the matching node in the branch of the document after a location. */\nexport const getNextNode = <N extends NodeOf<E>, E extends TEditor = TEditor>(\n  editor: E,\n  options?: GetNextNodeOptions<E>\n): TNodeEntry<N> | undefined =>\n  Editor.next(editor as any, options as any) as any;\n","import { type EditorNodeOptions, type Location, Editor } from 'slate';\n\nimport type { NodeOf } from '../node/TNode';\nimport type { TNodeEntry } from '../node/TNodeEntry';\nimport type { TEditor } from './TEditor';\n\n/** Get the node at a location. */\nexport const getNodeEntry = <N extends NodeOf<E>, E extends TEditor = TEditor>(\n  editor: E,\n  at: Location,\n  options?: EditorNodeOptions\n): TNodeEntry<N> | undefined => {\n  try {\n    return Editor.node(editor as any, at, options) as any;\n  } catch (error) {}\n};\n","import { type EditorPathOptions, type Location, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Get the path of a location. */\nexport const getPath = (\n  editor: TEditor,\n  at: Location,\n  options?: EditorPathOptions\n) => Editor.path(editor as any, at, options as any);\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Get the set of currently tracked path refs of the editor. */\nexport const getPathRefs = (editor: TEditor) => Editor.pathRefs(editor as any);\n","import { type EditorPointOptions, type Location, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Get the start or end point of a location. */\nexport const getPoint = (\n  editor: TEditor,\n  at: Location,\n  options?: EditorPointOptions\n) => Editor.point(editor as any, at, options);\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Get the set of currently tracked point refs of the editor. */\nexport const getPointRefs = (editor: TEditor) =>\n  Editor.pointRefs(editor as any);\n","import { type EditorPositionsOptions, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/**\n * Iterate through all of the positions in the document where a `Point` can be\n * placed.\n *\n * By default it will move forward by individual offsets at a time, but you can\n * pass the `unit: 'character'` option to moved forward one character, word, or\n * line at at time.\n *\n * Note: By default void nodes are treated as a single point and iteration will\n * not happen inside their content unless you pass in true for the voids option,\n * then iteration will occur.\n */\nexport const getPositions = (\n  editor: TEditor,\n  options?: EditorPositionsOptions\n) => Editor.positions(editor as any, options);\n","import { type Location, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Get a range of a location. */\nexport const getRange = (editor: TEditor, at: Location, to?: Location) =>\n  Editor.range(editor as any, at, to);\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Get the set of currently tracked range refs of the editor. */\nexport const getRangeRefs = (editor: TEditor) =>\n  Editor.rangeRefs(editor as any);\n","import { Editor } from 'slate';\n\nimport type { TElement } from '../element/TElement';\nimport type { TEditor } from './TEditor';\n\n/** Check if a node has block children. */\nexport const hasBlocks = (editor: TEditor, element: TElement) =>\n  Editor.hasBlocks(editor as any, element);\n","import { Editor } from 'slate';\n\nimport type { TElement } from '../element/TElement';\nimport type { TEditor } from './TEditor';\n\n/** Check if a node has inline and text children. */\nexport const hasInlines = (editor: TEditor, element: TElement) =>\n  Editor.hasInlines(editor as any, element);\n","import { Editor } from 'slate';\n\nimport type { TElement } from '../element/TElement';\nimport type { TEditor } from './TEditor';\n\n/** Check if a node has text children. */\nexport const hasTexts = (editor: TEditor, element: TElement) =>\n  Editor.hasTexts(editor as any, element);\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/**\n * Insert a block break at the current selection.\n *\n * If the selection is currently expanded, it will be deleted first.\n */\nexport const insertBreak = (editor: TEditor) =>\n  Editor.insertBreak(editor as any);\n","import { Editor } from 'slate';\n\nimport type { ElementOrTextOf } from '../element/TElement';\nimport type { TEditor } from './TEditor';\n\n/**\n * Insert a node at the current selection.\n *\n * If the selection is currently expanded, it will be deleted first.\n */\nexport const insertNode = <E extends TEditor>(\n  editor: E,\n  node: ElementOrTextOf<E> | ElementOrTextOf<E>[]\n) => Editor.insertNode(editor as any, node as any);\n","import { type Location, type Point, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Check if a point is an edge of a location. */\nexport const isEdgePoint = (editor: TEditor, point: Point, at: Location) =>\n  Editor.isEdge(editor as any, point, at);\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Check if a value is an `Editor` object. */\nexport const isEditor = (value: any): value is TEditor =>\n  Editor.isEditor(value);\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Check if the editor is currently normalizing after each operation. */\nexport const isEditorNormalizing = (editor: TEditor) =>\n  Editor.isNormalizing(editor as any);\n","import { type Location, type Point, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/**\n * Check if a point is the end point of a location. If point is null, return\n * false.\n */\nexport const isEndPoint = (\n  editor: TEditor,\n  point: Point | null | undefined,\n  at: Location\n) => !!point && Editor.isEnd(editor as any, point, at);\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\nimport { isElement } from '../element';\n\n/** Check if a value is an inline `Element` object. */\nexport const isInline = (editor: TEditor, value: any): boolean =>\n  isElement(value) && Editor.isInline(editor as any, value);\n","import type { TEditor } from './TEditor';\n\nimport { isElement } from '../element';\n\n/** Check if a value is a markable void `Element` object. */\nexport const isMarkableVoid = (editor: TEditor, value: any): boolean => {\n  return isElement(value) && editor.markableVoid(value);\n};\n","import { type Location, type Point, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/**\n * Check if a point is the start point of a location. If point is null, return\n * false.\n */\nexport const isStartPoint = (\n  editor: TEditor,\n  point: Point | null | undefined,\n  at: Location\n) => !!point && Editor.isStart(editor as any, point, at);\n","import { type EditorNormalizeOptions, Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/** Normalize any dirty objects in the editor. */\nexport const normalizeEditor = (\n  editor: TEditor,\n  options?: EditorNormalizeOptions\n) => Editor.normalize(editor as any, options);\n","import { Editor } from 'slate';\n\nimport type { TEditor } from './TEditor';\n\n/**\n * Remove a custom property from all of the leaf text nodes in the current\n * selection.\n *\n * If the selection is currently collapsed, the removal will be stored on\n * `editor.marks` and applied to the text inserted next.\n */\nexport const removeEditorMark = (editor: TEditor, key: string) =>\n  Editor.removeMark(editor as any, key);\n","import { type BaseEditor, Editor } from 'slate';\n\nimport { History } from './history';\n\n/** Weakmaps for attaching state to the editor. */\n\nexport const HISTORY = new WeakMap<Editor, History>();\n\nexport const SAVING = new WeakMap<Editor, boolean | undefined>();\n\nexport const MERGING = new WeakMap<Editor, boolean | undefined>();\n\nexport const SPLITTING_ONCE = new WeakMap<Editor, boolean | undefined>();\n\n/** `HistoryEditor` contains helpers for history-enabled editors. */\n\nexport interface HistoryEditor extends BaseEditor {\n  history: History;\n  redo: () => void;\n  undo: () => void;\n  writeHistory: (stack: 'redos' | 'undos', batch: any) => void;\n}\n\n// eslint-disable-next-line no-redeclare\nexport const HistoryEditor = {\n  /** Check if a value is a `HistoryEditor` object. */\n\n  isHistoryEditor(value: any): value is HistoryEditor {\n    return History.isHistory(value.history) && Editor.isEditor(value);\n  },\n\n  /** Get the merge flag's current value. */\n\n  isMerging(editor: HistoryEditor): boolean | undefined {\n    return MERGING.get(editor);\n  },\n\n  /** Get the splitting once flag's current value. */\n\n  isSaving(editor: HistoryEditor): boolean | undefined {\n    return SAVING.get(editor);\n  },\n\n  isSplittingOnce(editor: HistoryEditor): boolean | undefined {\n    return SPLITTING_ONCE.get(editor);\n  },\n\n  /** Get the saving flag's current value. */\n\n  redo(editor: HistoryEditor): void {\n    editor.redo();\n  },\n\n  /** Redo to the previous saved state. */\n\n  setSplittingOnce(editor: HistoryEditor, value: boolean | undefined): void {\n    SPLITTING_ONCE.set(editor, value);\n  },\n\n  /** Undo to the previous saved state. */\n\n  undo(editor: HistoryEditor): void {\n    editor.undo();\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, These operations will\n   * be merged into the previous history.\n   */\n  withMerging(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, ensuring that the\n   * first operation starts a new batch in the history. Subsequent operations\n   * will be merged as usual.\n   */\n  withNewBatch(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, true);\n    SPLITTING_ONCE.set(editor, true);\n    fn();\n    MERGING.set(editor, prev);\n    SPLITTING_ONCE.delete(editor);\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n\n  withoutMerging(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n\n  withoutSaving(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  },\n};\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n//@ts-ignore\nimport { isPlainObject } from 'is-plain-object';\nimport { type Range, Operation } from 'slate';\n\ninterface Batch {\n  operations: Operation[];\n  selectionBefore: Range | null;\n}\n\n/**\n * `History` objects hold all of the operations that are applied to a value, so\n * they can be undone or redone as necessary.\n */\n\nexport interface History {\n  redos: Batch[];\n  undos: Batch[];\n}\n\n// eslint-disable-next-line no-redeclare\nexport const History = {\n  /** Check if a value is a `History` object. */\n\n  isHistory(value: any): value is History {\n    return (\n      isPlainObject(value) &&\n      Array.isArray(value.redos) &&\n      Array.isArray(value.undos) &&\n      (value.redos.length === 0 ||\n        Operation.isOperationList(value.redos[0].operations)) &&\n      (value.undos.length === 0 ||\n        Operation.isOperationList(value.undos[0].operations))\n    );\n  },\n};\n","import { Editor, Operation, Path, Transforms } from 'slate';\n\nimport { HistoryEditor } from './history-editor';\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use this\n * plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\n\nexport const withHistory = <T extends Editor>(editor: T) => {\n  const e = editor as T & HistoryEditor;\n  const { apply } = e;\n  e.history = { redos: [], undos: [] };\n\n  e.redo = () => {\n    const { history } = e;\n    const { redos } = history;\n\n    if (redos.length > 0) {\n      const batch = redos.at(-1)!;\n\n      if (batch.selectionBefore) {\n        Transforms.setSelection(e, batch.selectionBefore);\n      }\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (const op of batch.operations) {\n            e.apply(op);\n          }\n        });\n      });\n\n      history.redos.pop();\n      e.writeHistory('undos', batch);\n    }\n  };\n\n  e.undo = () => {\n    const { history } = e;\n    const { undos } = history;\n\n    if (undos.length > 0) {\n      const batch = undos.at(-1)!;\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          const inverseOps = batch.operations.map(Operation.inverse).reverse();\n\n          for (const op of inverseOps) {\n            e.apply(op);\n          }\n\n          if (batch.selectionBefore) {\n            Transforms.setSelection(e, batch.selectionBefore);\n          }\n        });\n      });\n\n      e.writeHistory('redos', batch);\n      history.undos.pop();\n    }\n  };\n\n  e.apply = (op: Operation) => {\n    const { history, operations } = e;\n    const { undos } = history;\n    const lastBatch = undos.at(-1);\n    const lastOp = lastBatch?.operations.at(-1);\n    let save = HistoryEditor.isSaving(e);\n    let merge = HistoryEditor.isMerging(e);\n\n    if (save == null) {\n      save = shouldSave(op, lastOp);\n    }\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length > 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp);\n        }\n      }\n      if (HistoryEditor.isSplittingOnce(e)) {\n        merge = false;\n        HistoryEditor.setSplittingOnce(e, undefined);\n      }\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op);\n      } else {\n        const batch = {\n          operations: [op],\n          selectionBefore: e.selection,\n        };\n        e.writeHistory('undos', batch);\n      }\n\n      while (undos.length > 100) {\n        undos.shift();\n      }\n\n      history.redos = [];\n    }\n\n    apply(op);\n  };\n\n  e.writeHistory = (stack: 'redos' | 'undos', batch: any) => {\n    e.history[stack].push(batch);\n  };\n\n  return e;\n};\n\n/** Check whether to merge an operation into the previous operation. */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true;\n  }\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/** Check whether an operation needs to be saved to the history. */\n\nconst shouldSave = (op: Operation, _: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n\n  return true;\n};\n","import type { TEditor } from '../editor';\n\nimport { HistoryEditor } from '../../slate-history';\n\n/** {@link HistoryEditor.isHistoryEditor} */\nexport const isHistoryEditor = (value: any): value is TEditor =>\n  HistoryEditor.isHistoryEditor(value as any);\n","import type { TEditor } from '../editor';\n\nimport { HistoryEditor } from '../../slate-history';\n\n/** {@link HistoryEditor.isMerging} */\nexport const isHistoryMerging = (editor: TEditor) =>\n  HistoryEditor.isMerging(editor as any);\n","import type { TEditor } from '../editor';\n\nimport { HistoryEditor } from '../../slate-history';\n\n/** {@link HistoryEditor.isSaving} */\nexport const isHistorySaving = (editor: TEditor) =>\n  HistoryEditor.isSaving(editor as any);\n","import type { TEditor } from '../editor';\n\nimport { HistoryEditor } from '../../slate-history';\n\n/** {@link HistoryEditor.withMerging} */\nexport const withMerging = (editor: TEditor, fn: () => void) =>\n  HistoryEditor.withMerging(editor as any, fn);\n","import type { TEditor } from '../editor';\n\nimport { HistoryEditor } from '../../slate-history';\n\n/** {@link HistoryEditor.withMerging} */\nexport const withNewBatch = (editor: TEditor, fn: () => void) =>\n  HistoryEditor.withNewBatch(editor as any, fn);\n","import type { TEditor } from '../editor';\n\nimport { HistoryEditor } from '../../slate-history';\n\n/** {@link HistoryEditor.withoutMerging} */\nexport const withoutMergingHistory = (editor: TEditor, fn: () => void) =>\n  HistoryEditor.withoutMerging(editor as any, fn);\n","import type { TEditor } from '../editor';\n\nimport { HistoryEditor } from '../../slate-history';\n\n/** {@link HistoryEditor.withoutSaving} */\nexport const withoutSavingHistory = (editor: TEditor, fn: () => void) =>\n  HistoryEditor.withoutSaving(editor as any, fn);\n","import type { TEditor } from '../editor/TEditor';\nimport type { ElementOf, TElement } from '../element/TElement';\nimport type { TText, TextOf } from '../text/TText';\nimport type { TNode } from './TNode';\n\nimport { isElement } from '../element/isElement';\nimport { isText } from '../text/isText';\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\nexport type TDescendant = TElement | TText;\n\n/** A utility type to get all the descendant node types from a root node type. */\nexport type DescendantOf<N extends TNode> = N extends TEditor\n  ? ElementOf<N> | TextOf<N>\n  : N extends TElement\n    ? ElementOf<N['children'][number]> | TextOf<N>\n    : never;\n\n/** A utility type to get the child node types from a root node type. */\nexport type ChildOf<\n  N extends TNode,\n  I extends number = number,\n> = N extends TEditor\n  ? N['children'][I]\n  : N extends TElement\n    ? N['children'][I]\n    : never;\n\nexport const isDescendant: (value: any) => value is TDescendant = ((\n  node: any\n) => isElement(node) || isText(node)) as any;\n","import { type Path, Node } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/** Get an entry for the common ancesetor node of two paths. */\nexport const getCommonNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  another: Path\n) => Node.common(root, path, another) as TNodeEntry<N>;\n","import { Text } from 'slate';\n\nimport type { TText } from './TText';\n\n/** Check if a value is a list of `Text` objects. */\nexport const isTextList = (value: any): value is TText[] =>\n  Text.isTextList(value);\n","import { Text } from 'slate';\n\nimport type { TText } from './TText';\n\n/** Check if two text nodes are equal. */\nexport const textEquals = (text: TText, another: TText) =>\n  Text.equals(text, another);\n","import { Text } from 'slate';\n\nimport type { TText } from './TText';\n\n/**\n * Check if an text matches set of properties.\n *\n * Note: this is for matching custom properties, and it does not ensure that the\n * `text` property are two nodes equal.\n */\nexport const textMatches = <T extends TText>(text: T, props: object) =>\n  Text.matches(text, props);\n","import type { Path } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\n\nimport { isText } from '../text';\n\n/**\n * Get the descendant node referred to by a specific path. If the path is an\n * empty array, it refers to the root node itself. If the node is not found,\n * return null. Based on Slate get and has, performance optimization without\n * overhead of stringify on throwing\n */\nexport const getNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => {\n  try {\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i];\n\n      if (isText(root) || !root.children[p]) {\n        return null;\n      }\n\n      root = root.children[p] as R;\n    }\n\n    return root as N;\n  } catch (error) {\n    return null;\n  }\n};\n","import { type Path, Node } from 'slate';\n\nimport type { AncestorOf } from './TAncestor';\nimport type { TNode } from './TNode';\n\n/** Get the node at a specific path, asserting that it's an ancestor node. */\nexport const getNodeAncestor = <\n  N extends AncestorOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path\n) => Node.ancestor(root, path) as N;\n","import { type NodeAncestorsOptions, type Path, Node } from 'slate';\n\nimport type { AncestorOf } from './TAncestor';\nimport type { TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the ancestor nodes above a specific path.\n *\n * By default the order is bottom-up, from lowest to highest ancestor in the\n * tree, but you can pass the `reverse: true` option to go top-down.\n */\nexport const getNodeAncestors = <\n  N extends AncestorOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path,\n  options?: NodeAncestorsOptions\n) =>\n  Node.ancestors(root, path, options) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { Node } from 'slate';\n\nimport type { ChildOf } from './TDescendant';\nimport type { TNode } from './TNode';\n\n/** Get the child of a node at a specific index. */\nexport const getNodeChild = <\n  N extends ChildOf<R, I>,\n  R extends TNode = TNode,\n  I extends number = number,\n>(\n  root: R,\n  index: I\n) => Node.child(root, index) as N;\n","import { type NodeChildrenOptions, type Path, Node } from 'slate';\n\nimport type { ChildOf } from './TDescendant';\nimport type { TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/** Iterate over the children of a node at a specific path. */\nexport const getNodeChildren = <N extends ChildOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  options?: NodeChildrenOptions\n) =>\n  Node.children(root, path, options) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { type Path, Node } from 'slate';\n\nimport type { DescendantOf } from './TDescendant';\nimport type { TNode } from './TNode';\n\n/** Get the node at a specific path, asserting that it's a descendant node. */\nexport const getNodeDescendant = <\n  N extends DescendantOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  path: Path\n) => Node.descendant(root, path) as N;\n","import type { Modify } from '@udecode/utils';\n\nimport { type NodeDescendantsOptions, Node } from 'slate';\n\nimport type { DescendantOf } from './TDescendant';\nimport type { TNode } from './TNode';\nimport type { TDescendantEntry, TNodeEntry } from './TNodeEntry';\n\n/** Return a generator of all the descendant node entries inside a root node. */\nexport const getNodeDescendants = <\n  N extends DescendantOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeDescendantsOptions>,\n    {\n      pass?: (node: TDescendantEntry<N>) => boolean;\n    }\n  >\n) =>\n  Node.descendants(root, options as any) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import type { Modify } from '@udecode/utils';\n\nimport { type NodeElementsOptions, Node } from 'slate';\n\nimport type { ElementOf } from '../element/TElement';\nimport type { TNode } from './TNode';\nimport type { TElementEntry, TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the element nodes inside a root node. Each\n * iteration will return an `ElementEntry` tuple consisting of `[Element,\n * Path]`. If the root node is an element it will be included in the iteration\n * as well.\n */\nexport const getNodeElements = <\n  N extends ElementOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeElementsOptions>,\n    {\n      pass?: (node: TElementEntry<N>) => boolean;\n    }\n  >\n) =>\n  Node.elements(root, options as any) as Generator<\n    TNodeEntry<N>,\n    void,\n    undefined\n  >;\n","import { type Path, Node } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/** Get the first node entry in a root node from a path. */\nexport const getNodeFirstNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.first(root, path) as TNodeEntry<N>;\n","import { type Range, Node } from 'slate';\n\nimport type { ElementOf } from '../element/TElement';\nimport type { TextOf } from '../text/TText';\nimport type { TNode } from './TNode';\n\n/** Get the sliced fragment represented by a range inside a root node. */\nexport const getNodeFragment = <\n  N extends ElementOf<R> | TextOf<R>,\n  R extends TNode = TNode,\n>(\n  root: R,\n  range: Range\n) => Node.fragment(root, range) as N[];\n","import { type Path, Node } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/** Get the last node entry in a root node from a path. */\nexport const getNodeLastNode = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.last(root, path) as TNodeEntry<N>;\n","import { type Path, Node } from 'slate';\n\nimport type { TextOf } from '../text/TText';\nimport type { TNode } from './TNode';\n\n/** Get the node at a specific path, ensuring it's a leaf text node. */\nexport const getNodeLeaf = <N extends TextOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.leaf(root, path) as N;\n","import { type NodeLevelsOptions, type Path, Node } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of the in a branch of the tree, from a specific path.\n *\n * By default the order is top-down, from lowest to highest node in the tree,\n * but you can pass the `reverse: true` option to go bottom-up.\n */\nexport const getNodeLevels = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path,\n  options?: NodeLevelsOptions\n) =>\n  Node.levels(root, path, options) as Generator<TNodeEntry<N>, void, undefined>;\n","import { type Path, Node } from 'slate';\n\nimport type { AncestorOf } from './TAncestor';\nimport type { TNode } from './TNode';\n\n/** Get the parent of a node at a specific path. */\nexport const getNodeParent = <N extends AncestorOf<R>, R extends TNode = TNode>(\n  root: R,\n  path: Path\n) => Node.parent(root, path) as N;\n","import { Node } from 'slate';\n\nimport type { TNode, TNodeProps } from './TNode';\n\n/** Extract the custom properties from a node. */\nexport const getNodeProps = <N extends TNode>(node: N) =>\n  Node.extractProps(node) as TNodeProps<N>;\n","import { Node } from 'slate';\n\nimport type { TNode } from './TNode';\n\n/**\n * Get the concatenated text string of a node's content.\n *\n * Note that this will not include spaces or line breaks between block nodes. It\n * is not a user-facing string, but a string for performing offset-related\n * computations for a node.\n */\nexport const getNodeString = (node: TNode) => Node.string(node);\n","import type { Modify } from '@udecode/utils';\n\nimport { type NodeTextsOptions as SlateNodeTextsOptions, Node } from 'slate';\n\nimport type { TextOf } from '../text/TText';\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\nexport type NodeTextsOptions<\n  N extends TextOf<R>,\n  R extends TNode = TNode,\n> = Modify<\n  NonNullable<SlateNodeTextsOptions>,\n  {\n    pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;\n  }\n>;\n\n/** Return a generator of all leaf text nodes in a root node. */\nexport const getNodeTexts = <N extends TextOf<R>, R extends TNode = TNode>(\n  root: R,\n  options?: NodeTextsOptions<N, R>\n) =>\n  Node.texts(root, options as any) as Generator<TNodeEntry<N>, void, undefined>;\n","import type { Modify } from '@udecode/utils';\n\nimport { type NodeNodesOptions, Node } from 'slate';\n\nimport type { NodeOf, TNode } from './TNode';\nimport type { TNodeEntry } from './TNodeEntry';\n\n/**\n * Return a generator of all the node entries of a root node. Each entry is\n * returned as a `[Node, Path]` tuple, with the path referring to the node's\n * position inside the root node.\n */\nexport const getNodes = <N extends NodeOf<R>, R extends TNode = TNode>(\n  root: R,\n  options?: Modify<\n    NonNullable<NodeNodesOptions>,\n    {\n      pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;\n    }\n  >\n) =>\n  Node.nodes(root, options as any) as Generator<TNodeEntry<N>, void, undefined>;\n","import { type Path, Node } from 'slate';\n\nimport type { TNode } from './TNode';\n\n/** Check if a descendant node exists at a specific path. */\nexport const hasNode = (root: TNode, path: Path) => Node.has(root, path);\n","import { Element } from 'slate';\n\nimport type { TAncestor } from './TAncestor';\n\n/** Check if a value implements the 'Ancestor' interface. */\nexport const isAncestor = (value: any): value is TAncestor =>\n  Element.isAncestor(value);\n","import { Node } from 'slate';\n\nimport type { TNode } from './TNode';\n\n/** Check if a value implements the `Node` interface. */\nexport const isNode = (value: any): value is TNode => Node.isNode(value);\n","import { Node } from 'slate';\n\nimport type { TNode } from './TNode';\n\n/** Check if a value is a list of `Node` objects. */\nexport const isNodeList = (value: any): value is TNode[] =>\n  Node.isNodeList(value);\n","import { Node } from 'slate';\n\nimport type { TNode } from './TNode';\n\n/** Check if a node matches a set of props. */\nexport const nodeMatches = (node: TNode, props: object) =>\n  Node.matches(node, props);\n","import { Range } from 'slate';\n\n/** See {@link Range.isCollapsed}. Return false if `range` is not defined. */\nexport const isCollapsed = (range?: Range | null) =>\n  !!range && Range.isCollapsed(range);\n","import { Range } from 'slate';\n\n/** See {@link Range.isExpanded}. Return false if `range` is not defined. */\nexport const isExpanded = (range?: Range | null) =>\n  !!range && Range.isExpanded(range);\n","import type { SelectionCollapseOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor } from '../editor/TEditor';\n\n/** Collapse the selection. */\nexport const collapseSelection = (\n  editor: TEditor,\n  options?: SelectionCollapseOptions\n) => {\n  Transforms.collapse(editor as any, options);\n};\n","import { Transforms } from 'slate';\n\nimport type { TEditor } from '../editor/TEditor';\n\n/** Unset the selection. */\nexport const deselect = (editor: TEditor) => {\n  Transforms.deselect(editor as any);\n};\n","import type { TextInsertFragmentOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor } from '../editor/TEditor';\nimport type { ElementOrTextOf } from '../element/TElement';\n\n/** Insert a fragment at a specific location in the editor. */\nexport const insertFragment = <\n  N extends ElementOrTextOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  fragment: N[],\n  options?: TextInsertFragmentOptions\n) => {\n  Transforms.insertFragment(editor as any, fragment, options);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Path, Transforms, removeNodes, withoutNormalizing } from 'slate';\n\nimport type { QueryNodeOptions } from '../../types';\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor } from '../editor/TEditor';\nimport type { ElementOrTextOf } from '../element/TElement';\n\nimport { queryNode } from '../../utils';\nimport { getAboveNode, getEndPoint, isInline } from '../editor';\nimport { type TDescendant, getNodeString } from '../node';\n\nexport type InsertNodesOptions<E extends TEditor = TEditor> = {\n  /**\n   * Insert the nodes after the currect block. Does not apply if the removeEmpty\n   * option caused the current block to be removed.\n   */\n  nextBlock?: boolean;\n\n  /**\n   * Remove the currect block if empty before inserting. Only applies to\n   * paragraphs by default, but can be customized by passing a QueryNodeOptions\n   * object.\n   */\n  removeEmpty?: QueryNodeOptions | boolean;\n} & Modify<\n  NonNullable<Parameters<typeof Transforms.insertNodes>[2]>,\n  NodeMatchOption<E>\n>;\n\n/** Insert nodes at a specific location in the Editor. */\nexport const insertNodes = <\n  N extends ElementOrTextOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  nodes: N | N[],\n  { nextBlock, removeEmpty, ...options }: InsertNodesOptions<E> = {}\n) => {\n  withoutNormalizing(editor as any, () => {\n    if (removeEmpty) {\n      const blockEntry = getAboveNode(editor, { at: options.at });\n\n      if (blockEntry) {\n        const queryNodeOptions: QueryNodeOptions =\n          removeEmpty === true\n            ? {\n                allow: ['p'],\n              }\n            : removeEmpty;\n\n        const { filter } = queryNodeOptions;\n\n        queryNodeOptions.filter = ([node, path]) => {\n          if (getNodeString(node)) return false;\n\n          const children = node.children as TDescendant[];\n\n          if (children.some((n) => isInline(editor, n))) return false;\n\n          return !filter || filter([node, path]);\n        };\n\n        if (queryNode(blockEntry, queryNodeOptions)) {\n          removeNodes(editor as any, { at: blockEntry[1] });\n          nextBlock = false;\n        }\n      }\n    }\n    if (nextBlock) {\n      const { at = editor.selection } = options;\n\n      if (at) {\n        const endPoint = getEndPoint(editor, at);\n\n        const blockEntry = getAboveNode(editor, {\n          at: endPoint,\n          block: true,\n        });\n\n        if (blockEntry) {\n          options.at = Path.next(blockEntry[1]);\n        }\n      }\n    }\n\n    Transforms.insertNodes(editor as any, nodes, options as any);\n  });\n};\n","import type { TNode, TNodeEntry } from '../interfaces';\nimport type { QueryNodeOptions } from '../types/QueryNodeOptions';\n\nfunction castArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\n/** Query the node entry. */\nexport const queryNode = <N extends TNode>(\n  entry?: TNodeEntry<N>,\n  { allow, exclude, filter, level, maxLevel }: QueryNodeOptions = {}\n) => {\n  if (!entry) return false;\n\n  const [node, path] = entry;\n\n  if (level) {\n    const levels = castArray(level);\n\n    if (!levels.includes(path.length)) {\n      return false;\n    }\n  }\n  if (maxLevel && path.length > maxLevel) {\n    return false;\n  }\n  if (filter && !filter(entry)) {\n    return false;\n  }\n  if (allow) {\n    const allows = castArray(allow);\n\n    if (allows.length > 0 && !allows.includes(node.type as any)) {\n      return false;\n    }\n  }\n  if (exclude) {\n    const excludes = castArray(exclude);\n\n    if (excludes.length > 0 && excludes.includes(node.type as any)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","import type { TextInsertTextOptions } from 'slate/dist/interfaces/transforms/text';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor } from '../editor/TEditor';\n\n/** Insert a string of text in the Editor. */\nexport const insertText = (\n  editor: TEditor,\n  text: string,\n  options?: TextInsertTextOptions\n) => {\n  Transforms.insertText(editor as any, text, options);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor } from '../editor/TEditor';\n\nexport type LiftNodesOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<Parameters<typeof Transforms.liftNodes>[1]>,\n  NodeMatchOption<E>\n>;\n\n/**\n * Lift nodes at a specific location upwards in the document tree, splitting\n * their parent in two if necessary.\n */\nexport const liftNodes = <E extends TEditor>(\n  editor: E,\n  options?: LiftNodesOptions<E>\n) => Transforms.liftNodes(editor as any, options as any);\n","import type { SelectionMoveOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor } from '../editor/TEditor';\n\n/** Move the selection's point forward or backward. */\nexport const moveSelection = (\n  editor: TEditor,\n  options?: SelectionMoveOptions\n) => {\n  Transforms.move(editor as any, options);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor } from '../editor/TEditor';\nimport type { NodeOf, TNodeProps } from '../node/TNode';\n\nexport type SetNodesOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<Parameters<typeof Transforms.setNodes>[2]>,\n  NodeMatchOption<E>\n>;\n\n/** Set new properties on the nodes at a location. */\nexport const setNodes = <N extends NodeOf<E>, E extends TEditor = TEditor>(\n  editor: E,\n  props: Partial<TNodeProps<N>>,\n  options?: SetNodesOptions<E>\n) => Transforms.setNodes(editor as any, props, options as any);\n","import type { SelectionSetPointOptions } from 'slate/dist/interfaces/transforms/selection';\n\nimport { type Point, Transforms } from 'slate';\n\nimport type { TEditor } from '../editor/TEditor';\n\n/** Set new properties on one of the selection's points. */\nexport const setPoint = (\n  editor: TEditor,\n  props: Partial<Point>,\n  options?: SelectionSetPointOptions\n) => {\n  Transforms.setPoint(editor as any, props, options);\n};\n","import { type Range, Transforms } from 'slate';\n\nimport type { TEditor } from '../editor/TEditor';\n\n/** Set new properties on the selection. */\nexport const setSelection = (editor: TEditor, props: Partial<Range>) => {\n  Transforms.setSelection(editor as any, props);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor } from '../editor/TEditor';\n\nexport type SplitNodesOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<Parameters<typeof Transforms.splitNodes>[1]>,\n  NodeMatchOption<E>\n>;\n\n/** Split the nodes at a specific location. */\nexport const splitNodes = <E extends TEditor>(\n  editor: E,\n  options?: SplitNodesOptions<E>\n) => Transforms.splitNodes(editor as any, options as any);\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor } from '../editor/TEditor';\nimport type { NodeOf, TNodeProps } from '../node/TNode';\n\nexport type UnsetNodesOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<Parameters<typeof Transforms.unsetNodes>[2]>,\n  NodeMatchOption<E>\n>;\n\n/** Unset properties on the nodes at a location. */\nexport const unsetNodes = <N extends NodeOf<E>, E extends TEditor = TEditor>(\n  editor: E,\n  props: (keyof TNodeProps<N>)[] | keyof TNodeProps<N>,\n  options?: UnsetNodesOptions<E>\n) => {\n  return Transforms.unsetNodes(editor as any, props as any, options as any);\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { TEditor } from '../editor/TEditor';\n\nimport { type ENodeMatchOptions, getQueryOptions } from '../../utils/match';\n\nexport type UnwrapNodesOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<Parameters<typeof Transforms.unwrapNodes>[1]>,\n  ENodeMatchOptions<E>\n>;\n\n/**\n * Unwrap the nodes at a location from a parent node, splitting the parent if\n * necessary to ensure that only the content in the range is unwrapped.\n */\nexport const unwrapNodes = <E extends TEditor>(\n  editor: E,\n  options?: UnwrapNodesOptions<E>\n) => {\n  Transforms.unwrapNodes(editor as any, getQueryOptions(editor, options));\n};\n","import type { Modify } from '@udecode/utils';\n\nimport { Transforms } from 'slate';\n\nimport type { NodeMatchOption } from '../../types/NodeMatchOption';\nimport type { TEditor } from '../editor/TEditor';\nimport type { ElementOf } from '../element/TElement';\n\nimport { unhangRange } from '../editor/unhangRange';\n\nexport type WrapNodesOptions<E extends TEditor = TEditor> = Modify<\n  NonNullable<Parameters<typeof Transforms.wrapNodes>[2]>,\n  NodeMatchOption<E>\n>;\n\n/**\n * Wrap the nodes at a location in a new container node, splitting the edges of\n * the range first to ensure that only the content in the range is wrapped.\n */\nexport const wrapNodes = <N extends ElementOf<E>, E extends TEditor = TEditor>(\n  editor: E,\n  element: N,\n  options?: WrapNodesOptions<E>\n) => {\n  unhangRange(editor, options?.at, options);\n\n  Transforms.wrapNodes(editor as any, element as any, options as any);\n};\n","import {\n  type GetNodeEntriesOptions,\n  type NodeOf,\n  type TEditor,\n  type TNodeEntry,\n  getNodeEntries,\n} from '../interfaces';\nimport { getQueryOptions } from '../utils';\n\nexport type FindNodeOptions<E extends TEditor = TEditor> =\n  GetNodeEntriesOptions<E>;\n\n/** Find node matching the condition. */\nexport const findNode = <N extends NodeOf<E>, E extends TEditor = TEditor>(\n  editor: E,\n  options: FindNodeOptions<E> = {}\n): TNodeEntry<N> | undefined => {\n  // Slate throws when things aren't found so we wrap in a try catch and return undefined on throw.\n  try {\n    const nodeEntries = getNodeEntries<N, E>(editor, {\n      at: editor.selection || [],\n      ...getQueryOptions(editor, options),\n    });\n\n    // eslint-disable-next-line no-unreachable-loop\n    for (const [node, path] of nodeEntries) {\n      return [node, path];\n    }\n  } catch (error) {\n    return undefined;\n  }\n};\n","import type { TEditor, TNode } from '../interfaces';\n\nimport { getQueryOptions } from '../utils';\nimport { type FindNodeOptions, findNode } from './findNode';\n\nexport const findNodePath = <E extends TEditor = TEditor>(\n  editor: E,\n  node: TNode,\n  options: FindNodeOptions<E> = {}\n) => {\n  const { match } = getQueryOptions(editor, options);\n\n  const nodeEntry = findNode(editor, {\n    at: [],\n    match: (n) => n === node && (!match || match(n)),\n    ...options,\n  });\n\n  return nodeEntry?.[1];\n};\n","import type { NodeOf, TEditor } from '../interfaces';\n\nimport { type FindNodeOptions, findNode } from './findNode';\n\n/**\n * Iterate through all of the nodes in the editor and break early for the first\n * truthy match. Otherwise returns false.\n */\nexport const someNode = <N extends NodeOf<E>, E extends TEditor = TEditor>(\n  editor: E,\n  options: FindNodeOptions<E>\n) => {\n  return !!findNode<N, E>(editor, options);\n};\n","import {\n  type Location,\n  type Node,\n  Editor,\n  Path,\n  Range,\n  Text,\n  Transforms,\n} from 'slate';\n\nimport type { TEditor } from '../interfaces/editor/TEditor';\n\nimport { getRange } from '../interfaces';\n\n/** Add marks to each node of a range. */\nexport const addRangeMarks = (\n  editor: TEditor,\n  props: any,\n  {\n    at = editor.selection,\n  }: {\n    at?: Location | null;\n  } = {}\n) => {\n  if (at) {\n    if (Path.isPath(at)) {\n      at = getRange(editor as any, at);\n    }\n\n    const match = (node: Node, path: Path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      const parentEntry = Editor.parent(editor as any, path);\n\n      if (!parentEntry) return false;\n\n      const [parentNode] = parentEntry;\n\n      return (\n        !editor.isVoid(parentNode as any) ||\n        editor.markableVoid(parentNode as any)\n      );\n    };\n    const isExpandedRange = Range.isExpanded(at as Range);\n    let markAcceptingVoidSelected = false;\n\n    if (!isExpandedRange) {\n      const selectedEntry = Editor.node(editor as any, at);\n\n      if (!selectedEntry) return;\n\n      const [selectedNode, selectedPath] = selectedEntry;\n\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        const parentEntry = Editor.parent(editor as any, selectedPath);\n\n        if (!parentEntry) return;\n\n        const [parentNode] = parentEntry;\n\n        markAcceptingVoidSelected =\n          parentNode && editor.markableVoid(parentNode as any);\n      }\n    }\n    if (isExpandedRange || markAcceptingVoidSelected) {\n      Transforms.setNodes(editor as any, props, {\n        at,\n        match,\n        split: true,\n        voids: true,\n      });\n    }\n    // else {\n    //   const marks = {\n    //     ...(Editor.marks(editor as any) || {}),\n    //     [key]: value,\n    //   };\n    //\n    //   editor.marks = marks;\n    //   if (!FLUSHING.get(editor as any)) {\n    //     editor.onChange();\n    //   }\n    // }\n  }\n};\n","import type { TEditor, TElement, TNodeProps } from '../interfaces';\n\nimport {\n  type SetNodesOptions,\n  setNodes,\n} from '../interfaces/transforms/setNodes';\n\nexport const setElements = (\n  editor: TEditor,\n  props: Partial<TNodeProps<TElement>>,\n  options?: SetNodesOptions\n) => setNodes<TElement>(editor, props, options);\n","import type {\n  NodeOf,\n  SetNodesOptions,\n  TEditor,\n  TNodeProps,\n} from '../interfaces';\n\nimport { findNodePath } from '../queries';\n\nexport const setNode = <N extends NodeOf<E>, E extends TEditor = TEditor>(\n  editor: E,\n  node: N,\n  props: Partial<TNodeProps<N>>,\n  options?: Omit<SetNodesOptions<E>, 'at'>\n) => {\n  const path = findNodePath(editor, node);\n\n  if (!path) return;\n\n  editor.setNodes(props, {\n    ...options,\n    at: path,\n  } as any);\n};\n","import { Path, Range } from 'slate';\n\nimport { type TEditor, getPointAfter, getPointBefore } from '../interfaces';\n\n/** Unhang the range of length 1 so both edges are in the same text node. */\nexport const unhangCharacterRange = (editor: TEditor, at: Range) => {\n  let [start, end] = Range.edges(at);\n\n  if (!Path.equals(start.path, end.path)) {\n    if (end.offset === 0) {\n      const pointAfter = getPointAfter(editor, start);\n\n      if (pointAfter) {\n        end = pointAfter;\n      }\n    } else {\n      const pointBefore = getPointBefore(editor, end);\n\n      if (pointBefore) {\n        start = pointBefore;\n      }\n    }\n  }\n\n  return { anchor: start, focus: end };\n};\n"],"mappings":"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","names":["Editor","Editor","Editor","Editor","Editor","Editor","Editor","Path","Range","Editor","Range","Editor","Editor","Element","Element","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Transforms","Transforms","Transforms","match","Range","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Range","Path","Editor","point","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Editor","Operation","Path","Transforms","Transforms","Editor","Operation","Path","Text","Text","Text","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Node","Element","Node","Node","Node","Range","Range","Transforms","Transforms","Transforms","Path","Transforms","removeNodes","withoutNormalizing","castArray","withoutNormalizing","removeNodes","Path","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","Transforms","match","Editor","Path","Range","Text","Transforms","Path","match","Text","Editor","Range","Transforms","Path","Range","Range","Path"]}