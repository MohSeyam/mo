import * as _udecode_slate from '@udecode/slate';
import { DescendantOf, TEditor, FindNodeOptions, TNodeEntry, AncestorOf, GetAboveNodeOptions, ElementOf, GetNodeEntriesOptions, ChildOf, TNode, TextOf, NodeTextsOptions, TElement, TText, ElementOrTextOf, AncestorEntryOf, TOperation, QueryNodeOptions, TAncestor, QueryEditorOptions, InsertNodesOptions, NodeEntryOf, RemoveNodesOptions, SetNodesOptions, TNodeProps, MarksOf, WrapNodesOptions, TDescendant } from '@udecode/slate';
import * as slate from 'slate';
import { Path, Location, Point, Range } from 'slate';
import { Modify } from '@udecode/utils';

/**
 * Iterate through all of the nodes in the editor and return the first match. If
 * no match is found, return undefined.
 */

/** Get the first descendant node matching the condition. */
declare const findDescendant: <N extends DescendantOf<E>, E extends TEditor = TEditor>(editor: E, options: FindNodeOptions<E>) => TNodeEntry<N> | undefined;

/** Get the top-level block. */
declare const getAncestorNode: (editor: TEditor, path?: Path) => _udecode_slate.TNodeEntry<_udecode_slate.NodeOf<TEditor>> | undefined;

/** Get the block above a location (default: selection). */
declare const getBlockAbove: <N extends AncestorOf<E>, E extends TEditor = TEditor>(editor: E, options?: GetAboveNodeOptions<E>) => _udecode_slate.TNodeEntry<N> | undefined;

declare const getBlocks: <N extends ElementOf<E>, E extends TEditor = TEditor>(editor: E, options?: GetNodeEntriesOptions<E>) => _udecode_slate.TNodeEntry<N>[];

/** Get children node entries of a node entry. TODO: try Node.children */
declare const getChildren: <N extends ChildOf<R>, R extends TNode = TNode>(nodeEntry: TNodeEntry<R>) => TNodeEntry<N>[];

/** Get the edge blocks above a location (default: selection). */
declare const getEdgeBlocksAbove: <N1 extends AncestorOf<E>, N2 extends AncestorOf<E> = N1, E extends TEditor = TEditor>(editor: E, { at: _at, ...options }?: GetAboveNodeOptions<E>) => [TNodeEntry<N1>, TNodeEntry<N2>] | null;

/** Get the first text node from a node. */
declare const getFirstNodeText: <N extends TextOf<R>, R extends TNode = TNode>(root: R, options?: NodeTextsOptions<N, R>) => _udecode_slate.TNodeEntry<N> | undefined;

type GetFragmentPropOptions = {
    key?: string;
    defaultValue?: string;
    getProp?: (node: TElement | TText) => any;
    mode?: 'all' | 'block' | 'text';
};
declare function getFragmentProp(fragment: TElement[], { key, defaultValue, getProp, mode }?: GetFragmentPropOptions): string | undefined;

/** Get the last child of a node or null if no children. */
declare const getLastChild: <N extends ChildOf<R>, R extends TNode>(nodeEntry: TNodeEntry<R>) => TNodeEntry<N> | null;
/** Get last child path. If there is no child, last index is 0. */
declare const getLastChildPath: <N extends TNode>(nodeEntry: TNodeEntry<N>) => Path;
/** Is the child path the last one of the parent. */
declare const isLastChild: <N extends TNode>(parentEntry: TNodeEntry<N>, childPath: Path) => boolean;

/** Get the last node at a given level. */
declare const getLastNodeByLevel: <N extends ElementOrTextOf<E>, E extends TEditor = TEditor>(editor: E, level: number) => TNodeEntry<N> | undefined;

/** Get selection mark value by key. */
declare const getMark: (editor: TEditor, key: string) => unknown;

/** Get the start point of the next node. */
declare const getNextNodeStartPoint: (editor: TEditor, at: Path) => slate.BasePoint | undefined;

/**
 * Get the next sibling nodes after a path.
 *
 * @param ancestorEntry Ancestor of the sibling nodes
 * @param path Path of the reference node
 */
declare const getNextSiblingNodes: <E extends TEditor>(ancestorEntry: AncestorEntryOf<E>, path: Path) => ElementOrTextOf<E>[];

/** Get node entries range. */
declare const getNodesRange: (editor: TEditor, nodeEntries: TNodeEntry[]) => slate.BaseRange | undefined;

/** Get typed editor operations. */
declare const getOperations: <E extends TEditor>(editor: E) => TOperation<DescendantOf<E>>[];

interface BeforeOptions {
    distance?: number | undefined;
    unit?: 'block' | 'character' | 'line' | 'offset' | 'word' | undefined;
}
interface PointBeforeOptions extends BeforeOptions {
    /** Lookup before the location until this predicate is true */
    match?: (value: {
        at: Location;
        beforePoint: Point;
        beforeString: string;
    }) => boolean;
    /**
     * If true, get the point after the matching point. If false, get the matching
     * point.
     */
    afterMatch?: boolean;
    /**
     * If true, `matchString` will be interpreted as regex expression(s).
     * Otherwise, it will be compared by string equality.
     *
     * @default false
     */
    matchByRegex?: boolean;
    /** Lookup before the location for `matchString`. */
    matchString?: string[] | string;
    /**
     * If true, lookup until the start of the editor value. If false, lookup until
     * the first invalid character.
     */
    skipInvalid?: boolean;
}
/**
 * {@link getPointBefore} with additional options. TODO: support for sequence of
 * any characters.
 */
declare const getPointBeforeLocation: (editor: TEditor, at: Location, options?: PointBeforeOptions) => any;

/**
 * Get the point from a location (default: selection). If the location is a
 * range, get the anchor point. If the location is a path, get the point at this
 * path with offset 0. If `focus` is true, get the focus point.
 */
declare const getPointFromLocation: (editor: TEditor, { at, focus, }?: {
    at?: Location | null;
    focus?: boolean;
}) => slate.BasePoint | undefined;

/**
 * If the start point is inside an inline void, get the point before or after
 * it.
 */
declare const getPointNextToVoid: (editor: TEditor, { after, at, }: {
    at: Point;
    /** Get the point after (instead of before) the void node. */
    after?: boolean;
}) => slate.BasePoint;

/**
 * Find the block before a block by id. If not found, find the first block by id
 * and return [null, its previous path]
 */
declare const getPreviousBlockById: <N extends ElementOf<E>, E extends TEditor = TEditor>(editor: TEditor, id: string, query?: QueryNodeOptions) => TNodeEntry<N> | undefined;

/** Get the end point of the previous node. */
declare const getPreviousNodeEndPoint: (editor: TEditor, at: Path) => slate.BasePoint | undefined;

declare const getPreviousPath: (path: Path) => Path | undefined;

declare const getPreviousSiblingNode: (editor: TEditor, path: Path) => (number[] | _udecode_slate.NodeOf<TEditor>)[] | undefined;

interface RangeBeforeOptions extends PointBeforeOptions {
}
/** Get range from {@link getPointBeforeLocation} to the end point of `at`. */
declare const getRangeBefore: (editor: TEditor, at: Location, options?: RangeBeforeOptions) => Range | undefined;

/**
 * Get the range from the start of the block above a location (default:
 * selection) to the location.
 */
declare const getRangeFromBlockStart: <E extends TEditor>(editor: E, options?: Omit<GetAboveNodeOptions<E>, "match">) => {
    anchor: slate.BasePoint;
    focus: slate.BasePoint;
} | undefined;

type GetSelectionFragmentOptions = {
    structuralTypes?: string[];
};
declare const getSelectionFragment: (editor: TEditor, options?: GetSelectionFragmentOptions) => TElement[];

/** Get the selected text. Return empty string if no selection. */
declare const getSelectionText: (editor: TEditor) => string;

/** Is an ancestor empty (empty text and no inline children). */
declare const isAncestorEmpty: (editor: TEditor, node: TAncestor) => boolean;

/** Is the block above the selection empty. */
declare const isBlockAboveEmpty: (editor: TEditor) => boolean;

/**
 * Is there empty text after the selection. If there is no leaf after the
 * selected leaf, return {@link isEndPoint}. Else, check if the next leaves are
 * empty.
 */
declare const isBlockTextEmptyAfterSelection: (editor: TEditor) => boolean;

declare const isDocumentEnd: (editor: TEditor) => boolean;

/**
 * Whether the editor is empty. An editor is empty if it has only one empty
 * element.
 */
declare const isEditorEmpty: (editor: TEditor) => boolean;

/** Is it the first child of the parent */
declare const isFirstChild: (path: Path) => boolean;

/** Is the mark defined in the selection. */
declare const isMarkActive: (editor: TEditor, type: string) => boolean;

/** Is a point at the end of a word */
declare const isPointAtWordEnd: (editor: TEditor, { at }: {
    at: Point;
}) => boolean;

/**
 * Is the range (default: selection) across blocks.
 *
 * - Return undefined if block not found
 * - Return boolean whether one of the block is not found, but the other is found
 * - Return boolean whether block paths are unequal
 */
declare const isRangeAcrossBlocks: <E extends TEditor>(editor: E, { at, ...options }?: {
    at?: Range | null;
} & Omit<GetAboveNodeOptions<E>, "at">) => boolean | undefined;

/** Whether the range is in the same block. */
declare const isRangeInSameBlock: <E extends TEditor>(editor: E, { at, ...options }?: {
    at?: Range | null;
} & Omit<GetAboveNodeOptions<E>, "at">) => boolean | undefined;

/** Is the range in the same single text path. */
declare const isRangeInSingleText: (at: Range) => boolean;

/** Is the selection focus at the end of its parent block. */
declare const isSelectionAtBlockEnd: <E extends TEditor>(editor: E, options?: GetAboveNodeOptions<E>) => boolean;

/**
 * Is the selection anchor or focus at the start of its parent block.
 *
 * Supports the same options provided by {@link getBlockAbove}.
 */
declare const isSelectionAtBlockStart: <E extends TEditor>(editor: E, options?: GetAboveNodeOptions<E>) => boolean;

declare const isSelectionCoverBlock: <E extends TEditor>(editor: E, { at, ...options }?: {
    at?: Range | null;
} & Omit<GetAboveNodeOptions<E>, "at">) => boolean | undefined;

/** Is the selection expanded. */
declare const isSelectionExpanded: (editor: TEditor) => boolean;

declare const isTextByPath: (editor: TEditor, path: Path) => boolean;

/**
 * Is the word at the point after a trigger (punctuation character)
 * https://github.com/ianstormtaylor/slate/blob/main/packages/slate/src/utils/string.ts#L6
 */
declare const isWordAfterTrigger: (editor: TEditor, { at, trigger }: {
    at: Point;
    trigger: string;
}) => {
    match: RegExpMatchArray | null;
    range: slate.BaseRange | undefined;
};

/** Query the editor state. */
declare const queryEditor: <E extends TEditor>(editor: E, { allow, at, exclude, filter, selectionAtBlockEnd, selectionAtBlockStart, }?: QueryEditorOptions<E>) => boolean;

declare const duplicateBlocks: (editor: TEditor, blocks: TNodeEntry[]) => void;

declare const insertElements: <E extends TEditor>(editor: E, nodes: TElement | TElement[], options?: InsertNodesOptions<E>) => void;

declare const insertEmptyElement: <E extends TEditor>(editor: E, type: string, options?: InsertNodesOptions<E>) => void;

interface MoveChildrenOptions<E extends TEditor = TEditor> {
    /** Parent node of the children to move. */
    at: NodeEntryOf<E> | Path;
    /** Path where to move the children. */
    to: Path;
    /**
     * Start index of the children to move. Example: 1 means children[0] will not
     * be moved.
     */
    fromStartIndex?: number;
    /** Condition for the child to be moved */
    match?: (entry: NodeEntryOf<E>) => boolean;
}
/** Move the children of a node to a path. Returns the number of children moved. */
declare const moveChildren: <E extends TEditor>(editor: E, { at, fromStartIndex, match, to }: MoveChildrenOptions<E>) => number;

/** Remove non-empty editor text nodes */
declare const removeEditorText: <E extends TEditor>(editor: E, { match, ...options }?: RemoveNodesOptions<E>) => void;

declare const removeEmptyPreviousBlock: <E extends TEditor>(editor: E, options?: GetAboveNodeOptions<E>) => void;

interface RemoveMarkOptions<E extends TEditor> extends Omit<SetNodesOptions<E>, 'match' | 'split'> {
    /** Mark or the array of marks that will be removed */
    key: string[] | string;
    /** Range where the mark(s) will be removed */
    at?: Range;
    /**
     * When location is not a Range, setting this to false can prevent the
     * onChange event of the editor to fire
     *
     * @default true
     */
    shouldChange?: boolean;
}
/** Remove mark and trigger `onChange` if collapsed selection. */
declare const removeMark: <E extends TEditor>(editor: E, { key, at, shouldChange, ...rest }: RemoveMarkOptions<E>) => void;

/** Remove node children. */
declare const removeNodeChildren: <E extends TEditor>(editor: E, path: Path, options?: Omit<RemoveNodesOptions<E>, "at">) => void;

/** Remove selection marks. */
declare const removeSelectionMark: (editor: TEditor) => void;

interface ReplaceNodeChildrenOptions<N extends ElementOrTextOf<E>, E extends TEditor = TEditor> {
    at: Path;
    nodes: N | N[];
    insertOptions?: Omit<InsertNodesOptions<E>, 'at'>;
    removeOptions?: Omit<RemoveNodesOptions<E>, 'at'>;
}
/** Replace node children: remove then insert. */
declare const replaceNodeChildren: <N extends ElementOrTextOf<E>, E extends TEditor = TEditor>(editor: E, { at, insertOptions, nodes, removeOptions }: ReplaceNodeChildrenOptions<N, E>) => void;

declare const replaceNode: <N extends ElementOrTextOf<E>, E extends TEditor = TEditor>(editor: E, { at, insertOptions, nodes, removeOptions }: ReplaceNodeChildrenOptions<N, E>) => void;

/** Select the end point of the block above the selection. */
declare const selectEndOfBlockAboveSelection: (editor: TEditor) => void;

declare const selectNodes: (editor: TEditor, nodes: TNodeEntry[]) => void;

declare const setBlockAboveNode: <N extends ElementOf<E>, E extends TEditor = TEditor>(editor: E, props: Partial<TNodeProps<N>>, options?: Omit<SetNodesOptions<E>, "at">) => void;
declare const setBlockAboveTexts: <N extends ElementOf<E>, E extends TEditor = TEditor>(editor: E, props: Partial<TNodeProps<N>>, options?: Omit<SetNodesOptions<E>, "at">) => void;

declare const setBlockNodes: <N extends ElementOf<E>, E extends TEditor = TEditor>(editor: E, props: Partial<TNodeProps<N>>, options?: GetNodeEntriesOptions<E>) => void;

/** Set marks to selected text. */
declare const setMarks: <E extends TEditor>(editor: E, marks: MarksOf<E>, clear?: string[] | string) => void;

interface ToggleMarkOptions {
    /** The mark key to toggle. */
    key: string;
    /** Mark keys to clear when adding the mark. */
    clear?: string[] | string;
}
/** Add or remove marks in the selection. */
declare const toggleMark: (editor: TEditor, { key, clear }: ToggleMarkOptions) => void;

/** Unwrap if the node type is in selection. Wrap otherwise. */
declare const toggleWrapNodes: (editor: TEditor, type: string) => void;

/**
 * Wrap node children into a single element:
 *
 * - Wraps the first child node into the element
 * - Move the other child nodes next to the element children.
 */
declare const wrapNodeChildren: <N extends ElementOf<E>, E extends TEditor = TEditor>(editor: E, element: N, options: Modify<WrapNodesOptions<E>, {
    at: Path;
}>) => void;

declare const createDocumentNode: (type?: string, text?: string, remaining?: TDescendant[]) => TDescendant[];

declare const createNode: (type?: string, text?: string) => TElement;

declare const unwrapStructuralNodes: (nodes: TElement[], { structuralTypes }?: GetSelectionFragmentOptions) => TElement[];

export { type BeforeOptions, type GetFragmentPropOptions, type GetSelectionFragmentOptions, type MoveChildrenOptions, type PointBeforeOptions, type RangeBeforeOptions, type RemoveMarkOptions, type ReplaceNodeChildrenOptions, type ToggleMarkOptions, createDocumentNode, createNode, duplicateBlocks, findDescendant, getAncestorNode, getBlockAbove, getBlocks, getChildren, getEdgeBlocksAbove, getFirstNodeText, getFragmentProp, getLastChild, getLastChildPath, getLastNodeByLevel, getMark, getNextNodeStartPoint, getNextSiblingNodes, getNodesRange, getOperations, getPointBeforeLocation, getPointFromLocation, getPointNextToVoid, getPreviousBlockById, getPreviousNodeEndPoint, getPreviousPath, getPreviousSiblingNode, getRangeBefore, getRangeFromBlockStart, getSelectionFragment, getSelectionText, insertElements, insertEmptyElement, isAncestorEmpty, isBlockAboveEmpty, isBlockTextEmptyAfterSelection, isDocumentEnd, isEditorEmpty, isFirstChild, isLastChild, isMarkActive, isPointAtWordEnd, isRangeAcrossBlocks, isRangeInSameBlock, isRangeInSingleText, isSelectionAtBlockEnd, isSelectionAtBlockStart, isSelectionCoverBlock, isSelectionExpanded, isTextByPath, isWordAfterTrigger, moveChildren, queryEditor, removeEditorText, removeEmptyPreviousBlock, removeMark, removeNodeChildren, removeSelectionMark, replaceNode, replaceNodeChildren, selectEndOfBlockAboveSelection, selectNodes, setBlockAboveNode, setBlockAboveTexts, setBlockNodes, setMarks, toggleMark, toggleWrapNodes, unwrapStructuralNodes, wrapNodeChildren };
