{"version":3,"sources":["../src/queries/findDescendant.ts","../src/queries/getAncestorNode.ts","../src/queries/getBlockAbove.ts","../src/queries/getBlocks.ts","../src/queries/getChildren.ts","../src/queries/getEdgeBlocksAbove.ts","../src/queries/getFirstNodeText.ts","../src/queries/getFragmentProp.ts","../src/queries/getLastChild.ts","../src/queries/getLastNodeByLevel.ts","../src/queries/getMark.ts","../src/queries/getNextNodeStartPoint.ts","../src/queries/getNextSiblingNodes.ts","../src/queries/getNodesRange.ts","../src/queries/getOperations.ts","../src/queries/getPointBeforeLocation.ts","../src/queries/isRangeAcrossBlocks.ts","../src/queries/getPointFromLocation.ts","../src/queries/getPointNextToVoid.ts","../src/queries/getPreviousBlockById.ts","../src/queries/getPreviousNodeEndPoint.ts","../src/queries/getPreviousPath.ts","../src/queries/getPreviousSiblingNode.ts","../src/queries/getRangeBefore.ts","../src/queries/getRangeFromBlockStart.ts","../src/queries/getSelectionFragment.ts","../src/utils/unwrapStructuralNodes.ts","../src/queries/getSelectionText.ts","../src/queries/isAncestorEmpty.ts","../src/queries/isBlockAboveEmpty.ts","../src/queries/isBlockTextEmptyAfterSelection.ts","../src/queries/isDocumentEnd.ts","../src/queries/isEditorEmpty.ts","../src/queries/isFirstChild.ts","../src/queries/isMarkActive.ts","../src/queries/isPointAtWordEnd.ts","../src/queries/isRangeInSameBlock.ts","../src/queries/isRangeInSingleText.ts","../src/queries/isSelectionAtBlockEnd.ts","../src/queries/isSelectionAtBlockStart.ts","../src/queries/isSelectionCoverBlock.ts","../src/queries/isSelectionExpanded.ts","../src/queries/isTextByPath.ts","../src/queries/isWordAfterTrigger.ts","../src/queries/queryEditor.ts","../src/transforms/duplicateBlocks.ts","../src/transforms/insertElements.ts","../src/transforms/insertEmptyElement.ts","../src/transforms/moveChildren.ts","../src/transforms/removeEditorText.ts","../src/transforms/removeEmptyPreviousBlock.ts","../src/transforms/removeMark.ts","../src/transforms/removeNodeChildren.ts","../src/transforms/removeSelectionMark.ts","../src/transforms/replaceNode.ts","../src/transforms/replaceNodeChildren.ts","../src/transforms/selectEndOfBlockAboveSelection.ts","../src/transforms/selectNodes.ts","../src/transforms/setBlockAboveNode.ts","../src/transforms/setBlockNodes.ts","../src/transforms/setMarks.ts","../src/transforms/toggleMark.ts","../src/transforms/toggleWrapNodes.ts","../src/transforms/wrapNodeChildren.ts","../src/utils/createDocumentNode.ts","../src/utils/createNode.ts"],"sourcesContent":["/**\n * Iterate through all of the nodes in the editor and return the first match. If\n * no match is found, return undefined.\n */\nimport {\n  type DescendantOf,\n  type FindNodeOptions,\n  type NodeEntryOf,\n  type TEditor,\n  type TNodeEntry,\n  getNodeDescendants,\n  getNodeEntry,\n  getPath,\n  isVoid,\n  match,\n} from '@udecode/slate';\nimport { Path, Range, Span } from 'slate';\n\n/** Get the first descendant node matching the condition. */\nexport const findDescendant = <\n  N extends DescendantOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  options: FindNodeOptions<E>\n): TNodeEntry<N> | undefined => {\n  // Slate throws when things aren't found so we wrap in a try catch and return undefined on throw.\n  try {\n    const {\n      at = editor.selection,\n      match: _match,\n      reverse = false,\n      voids = false,\n    } = options;\n\n    if (!at) return;\n\n    let from;\n    let to;\n\n    if (Span.isSpan(at)) {\n      [from, to] = at;\n    } else if (Range.isRange(at)) {\n      const first = getPath(editor, at, { edge: 'start' });\n      const last = getPath(editor, at, { edge: 'end' });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    let root: NodeEntryOf<E> = [editor, []];\n\n    if (Path.isPath(at)) {\n      root = getNodeEntry(editor, at) as any;\n    }\n\n    const nodeEntries = getNodeDescendants<N>(root[0], {\n      from,\n      pass: ([n]) => (voids ? false : isVoid(editor, n)),\n      reverse,\n      to,\n    });\n\n    for (const [node, path] of nodeEntries) {\n      if (match(node, path, _match as any)) {\n        return [node, (at as Path).concat(path)];\n      }\n    }\n  } catch (error) {\n    return undefined;\n  }\n};\n","import type { Path } from 'slate';\n\nimport { type TEditor, getNodeEntry } from '@udecode/slate';\n\n/** Get the top-level block. */\nexport const getAncestorNode = (editor: TEditor, path?: Path) => {\n  const { selection } = editor;\n\n  const at = path ? path[0] : selection?.focus?.path[0];\n\n  if (typeof at !== 'number') return;\n\n  return getNodeEntry(editor, [at]);\n};\n","import {\n  type AncestorOf,\n  type GetAboveNodeOptions,\n  type TEditor,\n  getAboveNode,\n} from '@udecode/slate';\n\n/** Get the block above a location (default: selection). */\nexport const getBlockAbove = <\n  N extends AncestorOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  options: GetAboveNodeOptions<E> = {}\n) =>\n  getAboveNode<N, E>(editor, {\n    ...options,\n    block: true,\n  });\n","import {\n  type ElementOf,\n  type GetNodeEntriesOptions,\n  type TEditor,\n  getNodeEntries,\n} from '@udecode/slate';\n\nexport const getBlocks = <N extends ElementOf<E>, E extends TEditor = TEditor>(\n  editor: E,\n  options?: GetNodeEntriesOptions<E>\n) => {\n  return [\n    ...getNodeEntries<N>(editor, {\n      ...options,\n      block: true,\n    }),\n  ];\n};\n","import type { Path } from 'slate';\n\nimport {\n  type ChildOf,\n  type TNode,\n  type TNodeEntry,\n  isAncestor,\n} from '@udecode/slate';\n\n/** Get children node entries of a node entry. TODO: try Node.children */\nexport const getChildren = <N extends ChildOf<R>, R extends TNode = TNode>(\n  nodeEntry: TNodeEntry<R>\n): TNodeEntry<N>[] => {\n  const [node, path] = nodeEntry;\n\n  if (isAncestor(node)) {\n    const { children } = node;\n\n    return children.map((child, index) => {\n      const childPath: Path = path.concat([index]);\n\n      return [child as N, childPath];\n    });\n  }\n\n  return [];\n};\n","import {\n  type AncestorOf,\n  type GetAboveNodeOptions,\n  type TEditor,\n  type TNodeEntry,\n  getEdgePoints,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/** Get the edge blocks above a location (default: selection). */\nexport const getEdgeBlocksAbove = <\n  N1 extends AncestorOf<E>,\n  N2 extends AncestorOf<E> = N1,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  { at: _at, ...options }: GetAboveNodeOptions<E> = {}\n): [TNodeEntry<N1>, TNodeEntry<N2>] | null => {\n  const at = _at ?? editor.selection;\n\n  if (!at) return null;\n\n  const [start, end] = getEdgePoints(editor, at ?? editor.selection);\n\n  const startBlock = getBlockAbove<N1>(editor, {\n    at: start,\n    ...options,\n  });\n\n  if (!startBlock) return null;\n\n  const endBlock = getBlockAbove<N2>(editor, {\n    at: end,\n    ...options,\n  });\n\n  if (!endBlock) return null;\n\n  return [startBlock, endBlock];\n};\n","import {\n  type NodeTextsOptions,\n  type TNode,\n  type TextOf,\n  getNodeTexts,\n} from '@udecode/slate';\n\n/** Get the first text node from a node. */\nexport const getFirstNodeText = <N extends TextOf<R>, R extends TNode = TNode>(\n  root: R,\n  options?: NodeTextsOptions<N, R>\n) => {\n  const texts = getNodeTexts(root, options);\n  const firstTextEntry = texts.next().value;\n\n  return firstTextEntry ?? undefined;\n};\n","import { type TElement, type TText, getNodeTexts } from '@udecode/slate';\n\nexport type GetFragmentPropOptions = {\n  key?: string;\n  defaultValue?: string;\n  getProp?: (node: TElement | TText) => any;\n  mode?: 'all' | 'block' | 'text';\n};\n\nexport function getFragmentProp(\n  fragment: TElement[],\n  { key, defaultValue, getProp, mode = 'block' }: GetFragmentPropOptions = {}\n): string | undefined {\n  if (fragment.length === 0) return defaultValue;\n\n  const getNodeValue =\n    getProp ??\n    ((node) => {\n      return node[key!]!;\n    });\n\n  let value: string | undefined;\n\n  for (const node of fragment) {\n    if (mode === 'block' || mode === 'all') {\n      const nodeValue = getNodeValue(node);\n\n      if (nodeValue !== undefined) {\n        if (value === undefined) {\n          value = nodeValue;\n        } else if (value !== nodeValue) {\n          return;\n        }\n        if (mode === 'block') continue;\n      } else if (mode === 'block') {\n        return defaultValue;\n      }\n    }\n    if (mode === 'text' || mode === 'all') {\n      const textEntries = Array.from(getNodeTexts(node));\n\n      for (const [text] of textEntries) {\n        const textValue = getNodeValue(text);\n\n        if (textValue !== undefined) {\n          if (value === undefined) {\n            value = textValue;\n          } else if (value !== textValue) {\n            return;\n          }\n        } else if (mode === 'text') {\n          return defaultValue;\n        }\n      }\n    }\n  }\n\n  return value;\n}\n","import {\n  type ChildOf,\n  type TNode,\n  type TNodeEntry,\n  isText,\n} from '@udecode/slate';\nimport { Path } from 'slate';\n\n/** Get the last child of a node or null if no children. */\nexport const getLastChild = <N extends ChildOf<R>, R extends TNode>(\n  nodeEntry: TNodeEntry<R>\n): TNodeEntry<N> | null => {\n  const [node, path] = nodeEntry;\n\n  if (isText(node)) return null;\n  if (node.children.length === 0) return null;\n\n  const children = node.children as N[];\n\n  return [children.at(-1) as N, path.concat([children.length - 1])];\n};\n\n/** Get last child path. If there is no child, last index is 0. */\nexport const getLastChildPath = <N extends TNode>(\n  nodeEntry: TNodeEntry<N>\n): Path => {\n  const lastChild = getLastChild(nodeEntry);\n\n  if (!lastChild) return nodeEntry[1].concat([-1]);\n\n  return lastChild[1];\n};\n\n/** Is the child path the last one of the parent. */\nexport const isLastChild = <N extends TNode>(\n  parentEntry: TNodeEntry<N>,\n  childPath: Path\n): boolean => {\n  const lastChildPath = getLastChildPath(parentEntry);\n\n  return Path.equals(lastChildPath, childPath);\n};\n","import {\n  type ChildOf,\n  type ElementOrTextOf,\n  type TEditor,\n  type TNode,\n  type TNodeEntry,\n  getLastNode,\n  isAncestor,\n} from '@udecode/slate';\n\nconst getLastChild = <N extends ChildOf<R>, R extends TNode>(\n  node: R,\n  level: number\n): N | R => {\n  if (!(level + 1) || !isAncestor(node)) return node;\n\n  const { children } = node;\n\n  const lastNode = children.at(-1)!;\n\n  return getLastChild(lastNode, level - 1) as N;\n};\n\n/** Get the last node at a given level. */\nexport const getLastNodeByLevel = <\n  N extends ElementOrTextOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  level: number\n): TNodeEntry<N> | undefined => {\n  const { children } = editor;\n\n  const lastNode = children.at(-1);\n\n  if (!lastNode) return;\n\n  const [, lastPath] = getLastNode(editor, []);\n\n  return [getLastChild(lastNode, level - 1) as N, lastPath.slice(0, level + 1)];\n};\n","import { type TEditor, getMarks } from '@udecode/slate';\n\n/** Get selection mark value by key. */\nexport const getMark = (editor: TEditor, key: string) => {\n  if (!editor) return;\n\n  const marks = getMarks(editor);\n\n  return (marks as any)?.[key] as unknown;\n};\n","import type { Path } from 'slate';\n\nimport { type TEditor, getNextNode, getStartPoint } from '@udecode/slate';\n\n/** Get the start point of the next node. */\nexport const getNextNodeStartPoint = (editor: TEditor, at: Path) => {\n  const nextEntry = getNextNode(editor, {\n    at,\n  });\n\n  if (!nextEntry) return;\n\n  return getStartPoint(editor, nextEntry[1]);\n};\n","import type { AncestorEntryOf, ElementOrTextOf, TEditor } from '@udecode/slate';\nimport type { Path } from 'slate';\n\n/**\n * Get the next sibling nodes after a path.\n *\n * @param ancestorEntry Ancestor of the sibling nodes\n * @param path Path of the reference node\n */\nexport const getNextSiblingNodes = <E extends TEditor>(\n  ancestorEntry: AncestorEntryOf<E>,\n  path: Path\n): ElementOrTextOf<E>[] => {\n  const [ancestor, ancestorPath] = ancestorEntry;\n\n  const leafIndex = path[ancestorPath.length];\n\n  const siblings: ElementOrTextOf<E>[] = [];\n  const ancestorChildren = ancestor.children as ElementOrTextOf<E>[];\n\n  if (leafIndex + 1 < ancestor.children.length) {\n    for (let i = leafIndex + 1; i < ancestor.children.length; i++) {\n      siblings.push(ancestorChildren[i]);\n    }\n  }\n\n  return siblings;\n};\n","import { type TEditor, type TNodeEntry, getRange } from '@udecode/slate';\n\n/** Get node entries range. */\nexport const getNodesRange = (editor: TEditor, nodeEntries: TNodeEntry[]) => {\n  if (nodeEntries.length === 0) return;\n\n  const firstBlockPath = nodeEntries[0][1];\n  const lastBlockPath = nodeEntries.at(-1)![1];\n\n  return getRange(editor, firstBlockPath, lastBlockPath);\n};\n","import type { DescendantOf, TEditor, TOperation } from '@udecode/slate';\n\n/** Get typed editor operations. */\nexport const getOperations = <E extends TEditor>(editor: E) =>\n  editor.operations as TOperation<DescendantOf<E>>[];\n","/* eslint-disable no-constant-condition */\nimport type { Location, Point } from 'slate';\n\nimport {\n  type TEditor,\n  getEditorString,\n  getPoint,\n  getPointBefore,\n} from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\nimport map from 'lodash/map.js';\n\nimport { isRangeAcrossBlocks } from './isRangeAcrossBlocks';\n\nexport interface BeforeOptions {\n  distance?: number | undefined;\n  unit?: 'block' | 'character' | 'line' | 'offset' | 'word' | undefined;\n}\n\nexport interface PointBeforeOptions extends BeforeOptions {\n  /** Lookup before the location until this predicate is true */\n  match?: (value: {\n    at: Location;\n    beforePoint: Point;\n    beforeString: string;\n  }) => boolean;\n\n  /**\n   * If true, get the point after the matching point. If false, get the matching\n   * point.\n   */\n  afterMatch?: boolean;\n\n  /**\n   * If true, `matchString` will be interpreted as regex expression(s).\n   * Otherwise, it will be compared by string equality.\n   *\n   * @default false\n   */\n  matchByRegex?: boolean;\n\n  /** Lookup before the location for `matchString`. */\n  matchString?: string[] | string;\n\n  /**\n   * If true, lookup until the start of the editor value. If false, lookup until\n   * the first invalid character.\n   */\n  skipInvalid?: boolean;\n}\n\n/**\n * {@link getPointBefore} with additional options. TODO: support for sequence of\n * any characters.\n */\nexport const getPointBeforeLocation = (\n  editor: TEditor,\n  at: Location,\n  options?: PointBeforeOptions\n) => {\n  if (!options || (!options.match && !options.matchString)) {\n    return getPointBefore(editor, at, options);\n  }\n\n  const unitOffset = !options.unit || options.unit === 'offset';\n\n  const matchStrings: string[] = options.matchString\n    ? castArray(options.matchString)\n    : [''];\n\n  const matchByRegex = options.matchByRegex ?? false;\n\n  let point: any;\n\n  matchStrings.some((matchString) => {\n    let beforeAt = at;\n    let previousBeforePoint = getPoint(editor, at, { edge: 'end' });\n\n    const stackLength = matchString.length + 1;\n    const stack: any[] = Array.from({ length: stackLength });\n\n    let count = 0;\n\n    while (true) {\n      const beforePoint = getPointBefore(editor, beforeAt, options);\n\n      // not found\n      if (!beforePoint) return;\n      // stop looking outside of current block\n      if (\n        isRangeAcrossBlocks(editor, {\n          at: {\n            anchor: beforePoint,\n            focus: previousBeforePoint,\n          },\n        })\n      ) {\n        return;\n      }\n\n      const beforeString = getEditorString(editor, {\n        anchor: beforePoint,\n        focus: previousBeforePoint,\n      });\n\n      let beforeStringToMatch = beforeString;\n\n      if (unitOffset && stackLength) {\n        stack.unshift({\n          point: beforePoint,\n          text: beforeString,\n        });\n        stack.pop();\n\n        beforeStringToMatch = map(stack.slice(0, -1), 'text').join('');\n      }\n\n      const isMatched = matchByRegex\n        ? !!matchString.match(beforeStringToMatch)\n        : beforeStringToMatch === matchString;\n\n      if (\n        isMatched ||\n        options.match?.({ at, beforePoint, beforeString: beforeStringToMatch })\n      ) {\n        if (options.afterMatch) {\n          if (stackLength && unitOffset) {\n            point = stack.at(-1)?.point;\n\n            return !!point;\n          }\n\n          point = previousBeforePoint;\n\n          return true;\n        }\n\n        point = beforePoint;\n\n        return true;\n      }\n\n      previousBeforePoint = beforePoint;\n      beforeAt = beforePoint;\n\n      count += 1;\n\n      if (!options.skipInvalid && (!matchString || count >= matchString.length))\n        return;\n    }\n  });\n\n  return point;\n};\n","import type { GetAboveNodeOptions, TEditor } from '@udecode/slate';\n\nimport { Path, Range } from 'slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * Is the range (default: selection) across blocks.\n *\n * - Return undefined if block not found\n * - Return boolean whether one of the block is not found, but the other is found\n * - Return boolean whether block paths are unequal\n */\nexport const isRangeAcrossBlocks = <E extends TEditor>(\n  editor: E,\n  {\n    at,\n    ...options\n  }: { at?: Range | null } & Omit<GetAboveNodeOptions<E>, 'at'> = {}\n) => {\n  if (!at) at = editor.selection;\n  if (!at) return;\n\n  const [start, end] = Range.edges(at);\n  const startBlock = getBlockAbove(editor, {\n    at: start,\n    ...options,\n  });\n  const endBlock = getBlockAbove(editor, {\n    at: end,\n    ...options,\n  });\n\n  if (!startBlock && !endBlock) return;\n  if (!startBlock || !endBlock) return true;\n\n  return !Path.equals(startBlock[1], endBlock[1]);\n};\n","import type { TEditor } from '@udecode/slate';\n\nimport { type Location, Path, Point, Range } from 'slate';\n\n/**\n * Get the point from a location (default: selection). If the location is a\n * range, get the anchor point. If the location is a path, get the point at this\n * path with offset 0. If `focus` is true, get the focus point.\n */\nexport const getPointFromLocation = (\n  editor: TEditor,\n  {\n    at = editor.selection,\n    focus,\n  }: {\n    at?: Location | null;\n    focus?: boolean;\n  } = {}\n) => {\n  let point: Point | undefined;\n\n  if (Range.isRange(at)) point = focus ? at.focus : at.anchor;\n  if (Point.isPoint(at)) point = at;\n  if (Path.isPath(at)) point = { offset: 0, path: at };\n\n  return point;\n};\n","import {\n  type TEditor,\n  getPointAfter,\n  getPointBefore,\n  getVoidNode,\n} from '@udecode/slate';\nimport { type Point, Path } from 'slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * If the start point is inside an inline void, get the point before or after\n * it.\n */\nexport const getPointNextToVoid = (\n  editor: TEditor,\n  {\n    after,\n    at,\n  }: {\n    at: Point;\n    /** Get the point after (instead of before) the void node. */\n    after?: boolean;\n  }\n) => {\n  const startVoid = getVoidNode(editor, { at, mode: 'highest' });\n\n  if (startVoid) {\n    const blockAbove = getBlockAbove(editor, { at });\n\n    if (blockAbove) {\n      const nextPoint = after\n        ? getPointAfter(editor, at)\n        : getPointBefore(editor, at);\n\n      if (\n        nextPoint &&\n        blockAbove &&\n        Path.isAncestor(blockAbove[1], nextPoint.path)\n      ) {\n        at = nextPoint;\n      }\n    }\n  }\n\n  return at;\n};\n","import {\n  type ElementOf,\n  type QueryNodeOptions,\n  type TEditor,\n  type TElement,\n  type TNodeEntry,\n  findNode,\n  getNodeEntries,\n  getPreviousNode,\n  isBlock,\n  queryNode,\n} from '@udecode/slate';\n\n/**\n * Find the block before a block by id. If not found, find the first block by id\n * and return [null, its previous path]\n */\nexport const getPreviousBlockById = <\n  N extends ElementOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: TEditor,\n  id: string,\n  query?: QueryNodeOptions\n): TNodeEntry<N> | undefined => {\n  const entry = findNode(editor, {\n    match: { id },\n  });\n\n  if (entry) {\n    const prevEntry = getPreviousNode<TElement>(editor, { at: entry[1] });\n\n    if (prevEntry?.[0].id && isBlock(editor, prevEntry[0])) {\n      return prevEntry as TNodeEntry<N>;\n    }\n  }\n\n  let found = false;\n  const _nodes = getNodeEntries<N>(editor, {\n    at: [],\n    match: (n) => {\n      // filter nodes that are not blocks and without id.\n      if (!isBlock(editor, n) || !n.id) return false;\n      // find the block then take the previous one.\n      if (n.id === id) {\n        found = true;\n\n        return false;\n      }\n\n      return found && n.id !== id && queryNode([n, []], query);\n    },\n    mode: 'highest',\n    reverse: true,\n  });\n  const nodeEntries = Array.from(_nodes);\n\n  if (nodeEntries.length > 0) {\n    return nodeEntries[0];\n  }\n  if (!found) return;\n\n  const _entries = getNodeEntries<TElement>(editor, {\n    at: [],\n    match: (n) => {\n      return isBlock(editor, n) && !!n.id && queryNode([n, []], query);\n    },\n    mode: 'highest',\n  });\n  const firstNodeEntry = Array.from(_entries);\n\n  if (firstNodeEntry.length > 0) {\n    const [, path] = firstNodeEntry[0];\n\n    path[path.length - 1] = path.at(-1)! - 1;\n\n    return [null, path] as any;\n  }\n};\n","import type { Path } from 'slate';\n\nimport { type TEditor, getEndPoint, getPreviousNode } from '@udecode/slate';\n\n/** Get the end point of the previous node. */\nexport const getPreviousNodeEndPoint = (editor: TEditor, at: Path) => {\n  const prevEntry = getPreviousNode(editor, {\n    at,\n  });\n\n  if (!prevEntry) return;\n\n  return getEndPoint(editor, prevEntry[1]);\n};\n","import type { Path } from 'slate';\n\nexport const getPreviousPath = (path: Path): Path | undefined => {\n  if (path.length === 0) return;\n\n  const last = path.at(-1)!;\n\n  if (last <= 0) return;\n\n  return path.slice(0, -1).concat(last - 1);\n};\n","import type { Path } from 'slate';\n\nimport { type TEditor, getNode } from '@udecode/slate';\nimport last from 'lodash/last.js';\n\nexport const getPreviousSiblingNode = (editor: TEditor, path: Path) => {\n  const index = last(path)!;\n\n  if (index > 0) {\n    const previousSiblingIndex = index - 1;\n    const previousSiblingPath = path\n      .slice(0, -1)\n      .concat([previousSiblingIndex]);\n    const previousSiblingNode = getNode(editor, previousSiblingPath);\n\n    return previousSiblingNode\n      ? [previousSiblingNode, previousSiblingPath]\n      : undefined;\n  }\n};\n","import type { Location, Range } from 'slate';\n\nimport { type TEditor, getPoint } from '@udecode/slate';\n\nimport {\n  type PointBeforeOptions,\n  getPointBeforeLocation,\n} from './getPointBeforeLocation';\n\nexport interface RangeBeforeOptions extends PointBeforeOptions {}\n\n/** Get range from {@link getPointBeforeLocation} to the end point of `at`. */\nexport const getRangeBefore = (\n  editor: TEditor,\n  at: Location,\n  options?: RangeBeforeOptions\n): Range | undefined => {\n  const anchor = getPointBeforeLocation(editor, at, options);\n\n  if (!anchor) return;\n\n  const focus = getPoint(editor, at, { edge: 'end' });\n\n  return {\n    anchor,\n    focus,\n  };\n};\n","import {\n  type GetAboveNodeOptions,\n  type TEditor,\n  getStartPoint,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\nimport { getPointFromLocation } from './getPointFromLocation';\n\n/**\n * Get the range from the start of the block above a location (default:\n * selection) to the location.\n */\nexport const getRangeFromBlockStart = <E extends TEditor>(\n  editor: E,\n  options: Omit<GetAboveNodeOptions<E>, 'match'> = {}\n) => {\n  const path = getBlockAbove(editor, options)?.[1];\n\n  if (!path) return;\n\n  const start = getStartPoint(editor, path);\n\n  const focus = getPointFromLocation(editor, options);\n\n  if (!focus) return;\n\n  return { anchor: start, focus };\n};\n","import { type TEditor, type TElement, getFragment } from '@udecode/slate';\n\nimport { unwrapStructuralNodes } from '../utils/unwrapStructuralNodes';\n\nexport type GetSelectionFragmentOptions = {\n  structuralTypes?: string[];\n};\n\nexport const getSelectionFragment = (\n  editor: TEditor,\n  options?: GetSelectionFragmentOptions\n) => {\n  if (!editor.selection) return [];\n\n  const fragment = getFragment(editor, editor.selection!) as TElement[];\n\n  if (fragment.length === 0) return [];\n\n  return unwrapStructuralNodes(fragment, options);\n};\n","import type { TElement } from '@udecode/slate';\n\nimport type { GetSelectionFragmentOptions } from '../queries/getSelectionFragment';\n\nexport const unwrapStructuralNodes = (\n  nodes: TElement[],\n  { structuralTypes }: GetSelectionFragmentOptions = {}\n) => {\n  const unwrap = (nodes: TElement[], acc: TElement[] = []): TElement[] => {\n    nodes.forEach((node) => {\n      if (structuralTypes?.includes(node.type)) {\n        return unwrap(node.children as TElement[], acc);\n      }\n\n      acc.push(node);\n    });\n\n    return acc;\n  };\n\n  return unwrap(nodes);\n};\n","import { type TEditor, getEditorString } from '@udecode/slate';\n\n/** Get the selected text. Return empty string if no selection. */\nexport const getSelectionText = (editor: TEditor) =>\n  getEditorString(editor, editor.selection);\n","import {\n  type TAncestor,\n  type TEditor,\n  getNodeString,\n  isInline,\n} from '@udecode/slate';\n\n/** Is an ancestor empty (empty text and no inline children). */\nexport const isAncestorEmpty = (editor: TEditor, node: TAncestor) =>\n  !getNodeString(node) && !node.children.some((n) => isInline(editor, n));\n","import type { TEditor } from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\nimport { isAncestorEmpty } from './isAncestorEmpty';\n\n/** Is the block above the selection empty. */\nexport const isBlockAboveEmpty = (editor: TEditor) => {\n  const block = getBlockAbove(editor)?.[0];\n\n  if (!block) return false;\n\n  return isAncestorEmpty(editor, block);\n};\n","import {\n  type TEditor,\n  getParentNode,\n  isEndPoint,\n  isText,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\nimport { getNextSiblingNodes } from './getNextSiblingNodes';\n\n/**\n * Is there empty text after the selection. If there is no leaf after the\n * selected leaf, return {@link isEndPoint}. Else, check if the next leaves are\n * empty.\n */\nexport const isBlockTextEmptyAfterSelection = (editor: TEditor) => {\n  if (!editor.selection) return false;\n\n  const blockAbove = getBlockAbove(editor);\n\n  if (!blockAbove) return false;\n\n  const cursor = editor.selection.focus;\n\n  const selectionParentEntry = getParentNode(editor, editor.selection);\n\n  if (!selectionParentEntry) return false;\n\n  const [, selectionParentPath] = selectionParentEntry;\n\n  if (!isEndPoint(editor, cursor, selectionParentPath)) return false;\n\n  const siblingNodes = getNextSiblingNodes(blockAbove, cursor.path);\n\n  if (siblingNodes.length > 0) {\n    for (const siblingNode of siblingNodes) {\n      if (isText(siblingNode) && siblingNode.text) {\n        return false;\n      }\n    }\n  } else {\n    return isEndPoint(editor, cursor, blockAbove[1]);\n  }\n\n  return true;\n};\n","import { type TEditor, getEndPoint, isEndPoint } from '@udecode/slate';\nimport { Path } from 'slate';\n\nexport const isDocumentEnd = (editor: TEditor) => {\n  if (editor.selection) {\n    const point = editor.selection.focus;\n    const endPoint = getEndPoint(editor, []);\n\n    return (\n      endPoint.offset === 0 &&\n      isEndPoint(editor, point, point) &&\n      Path.equals(Path.next(Path.parent(point.path)), endPoint.path)\n    );\n  }\n\n  return false;\n};\n","import { type TEditor, isElementEmpty } from '@udecode/slate';\n\n/**\n * Whether the editor is empty. An editor is empty if it has only one empty\n * element.\n */\nexport const isEditorEmpty = (editor: TEditor) => {\n  return (\n    editor.children.length === 1 &&\n    isElementEmpty(editor, editor.children[0] as any)\n  );\n};\n","import type { Path } from 'slate';\n\n/** Is it the first child of the parent */\nexport const isFirstChild = (path: Path) => path.at(-1) === 0;\n","import type { TEditor } from '@udecode/slate';\n\nimport { isDefined } from '@udecode/utils';\n\nimport { getMark } from './getMark';\n\n/** Is the mark defined in the selection. */\nexport const isMarkActive = (editor: TEditor, type: string) => {\n  return isDefined(getMark(editor, type));\n};\n","import type { Point } from 'slate';\n\nimport {\n  type TEditor,\n  getEditorString,\n  getPointAfter,\n  getRange,\n} from '@udecode/slate';\n\n// Starts with whitespace char or nothing\nconst AFTER_MATCH_REGEX = /^(?:\\s|$)/;\n\n/** Is a point at the end of a word */\nexport const isPointAtWordEnd = (editor: TEditor, { at }: { at: Point }) => {\n  // Point after at\n  const after = getPointAfter(editor, at);\n\n  // From at to after\n  const afterRange = getRange(editor, at, after);\n  const afterText = getEditorString(editor, afterRange);\n\n  // Match regex on after text\n  return !!AFTER_MATCH_REGEX.exec(afterText);\n};\n","import type { GetAboveNodeOptions, TEditor } from '@udecode/slate';\n\nimport { Path, Range } from 'slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/** Whether the range is in the same block. */\nexport const isRangeInSameBlock = <E extends TEditor>(\n  editor: E,\n  {\n    at,\n    ...options\n  }: { at?: Range | null } & Omit<GetAboveNodeOptions<E>, 'at'> = {}\n) => {\n  if (!at) at = editor.selection;\n  if (!at) return;\n\n  const [start, end] = Range.edges(at);\n  const startBlock = getBlockAbove(editor, {\n    at: start,\n    ...options,\n  });\n  const endBlock = getBlockAbove(editor, {\n    at: end,\n    ...options,\n  });\n\n  if (!startBlock || !endBlock) return;\n\n  return Path.equals(startBlock[1], endBlock[1]);\n};\n","import { Path, Range } from 'slate';\n\n/** Is the range in the same single text path. */\nexport const isRangeInSingleText = (at: Range) => {\n  const [start, end] = Range.edges(at);\n\n  return Path.equals(start.path, end.path);\n};\n","import {\n  type GetAboveNodeOptions,\n  type TEditor,\n  isEndPoint,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/** Is the selection focus at the end of its parent block. */\nexport const isSelectionAtBlockEnd = <E extends TEditor>(\n  editor: E,\n  options?: GetAboveNodeOptions<E>\n): boolean => {\n  const path = getBlockAbove(editor, options)?.[1];\n\n  return !!path && isEndPoint(editor, editor.selection?.focus, path);\n};\n","import {\n  type GetAboveNodeOptions,\n  type TEditor,\n  isExpanded,\n  isStartPoint,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from './getBlockAbove';\n\n/**\n * Is the selection anchor or focus at the start of its parent block.\n *\n * Supports the same options provided by {@link getBlockAbove}.\n */\nexport const isSelectionAtBlockStart = <E extends TEditor>(\n  editor: E,\n  options?: GetAboveNodeOptions<E>\n) => {\n  const { selection } = editor;\n\n  if (!selection) return false;\n\n  const path = getBlockAbove(editor, options)?.[1];\n\n  if (!path) return false;\n\n  return (\n    isStartPoint(editor, selection.focus, path) ||\n    (isExpanded(editor.selection) &&\n      isStartPoint(editor, selection.anchor, path))\n  );\n};\n","import type { GetAboveNodeOptions, TEditor } from '@udecode/slate';\nimport type { Range } from 'slate';\n\nimport { isRangeInSameBlock } from './isRangeInSameBlock';\nimport { isSelectionAtBlockEnd } from './isSelectionAtBlockEnd';\nimport { isSelectionAtBlockStart } from './isSelectionAtBlockStart';\n\n// TODO: test\nexport const isSelectionCoverBlock = <E extends TEditor>(\n  editor: E,\n  {\n    at,\n    ...options\n  }: { at?: Range | null } & Omit<GetAboveNodeOptions<E>, 'at'> = {}\n) => {\n  return (\n    isSelectionAtBlockEnd(editor, options) &&\n    isSelectionAtBlockStart(editor, options) &&\n    isRangeInSameBlock(editor, options)\n  );\n};\n","import { type TEditor, isExpanded } from '@udecode/slate';\n\n/** Is the selection expanded. */\nexport const isSelectionExpanded = (editor: TEditor) =>\n  isExpanded(editor.selection);\n","import type { Path } from 'slate';\n\nimport { type TEditor, getNode, isText } from '@udecode/slate';\n\nexport const isTextByPath = (editor: TEditor, path: Path) => {\n  const node = getNode(editor, path);\n\n  return isText(node);\n};\n","import type { Point } from 'slate';\n\nimport {\n  type TEditor,\n  getEditorString,\n  getPointBefore,\n  getRange,\n} from '@udecode/slate';\nimport { escapeRegExp } from '@udecode/utils';\n\n/**\n * Is the word at the point after a trigger (punctuation character)\n * https://github.com/ianstormtaylor/slate/blob/main/packages/slate/src/utils/string.ts#L6\n */\nexport const isWordAfterTrigger = (\n  editor: TEditor,\n  { at, trigger }: { at: Point; trigger: string }\n) => {\n  // Point at the start of previous word (excluding punctuation)\n  const wordBefore = getPointBefore(editor, at, { unit: 'word' });\n\n  // Point before wordBefore\n  const before = wordBefore && getPointBefore(editor, wordBefore);\n\n  // Range from before to start\n  const beforeRange = before && getRange(editor, before, at);\n\n  // Before text\n  const beforeText = getEditorString(editor, beforeRange);\n\n  // Starts with char and ends with word characters\n  const escapedTrigger = escapeRegExp(trigger);\n\n  const beforeRegex = new RegExp(\n    `^${escapedTrigger}([\\\\w|À-ÖØ-öø-ÿ|а-яА-ЯёЁ]+)$`\n  );\n\n  // Match regex on before text\n  const match = beforeText ? beforeText.match(beforeRegex) : null;\n\n  return {\n    match,\n    range: beforeRange,\n  };\n};\n","import {\n  type QueryEditorOptions,\n  type TEditor,\n  someNode,\n} from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\n\nimport { isSelectionAtBlockEnd } from './isSelectionAtBlockEnd';\nimport { isSelectionAtBlockStart } from './isSelectionAtBlockStart';\n\n/** Query the editor state. */\nexport const queryEditor = <E extends TEditor>(\n  editor: E,\n  {\n    allow,\n    at = editor.selection || [],\n    exclude,\n    filter,\n    selectionAtBlockEnd,\n    selectionAtBlockStart,\n  }: QueryEditorOptions<E> = {}\n) => {\n  if (\n    (filter && !filter(editor)) ||\n    (selectionAtBlockStart && !isSelectionAtBlockStart(editor)) ||\n    (selectionAtBlockEnd && !isSelectionAtBlockEnd(editor))\n  ) {\n    return false;\n  }\n\n  const allows = castArray(allow);\n\n  if (allows.length > 0 && !someNode(editor, { at, match: { type: allows } })) {\n    return false;\n  }\n\n  const excludes = castArray(exclude);\n\n  if (\n    excludes.length > 0 &&\n    someNode(editor, { at, match: { type: excludes } })\n  ) {\n    return false;\n  }\n\n  return true;\n};\n","import type { TEditor, TNodeEntry } from '@udecode/slate';\n\nimport { Path } from 'slate';\n\nexport const duplicateBlocks = (editor: TEditor, blocks: TNodeEntry[]) => {\n  const lastBlock = blocks.at(-1);\n\n  if (!lastBlock) return;\n\n  editor.insertNodes(blocks.map((item) => item[0]) as any, {\n    at: Path.next(lastBlock[1]),\n  });\n};\n","import {\n  type ElementOf,\n  type InsertNodesOptions,\n  type TEditor,\n  type TElement,\n  insertNodes,\n} from '@udecode/slate';\n\nexport const insertElements = <E extends TEditor>(\n  editor: E,\n  nodes: TElement | TElement[],\n  options?: InsertNodesOptions<E>\n) => {\n  insertNodes(editor, nodes as ElementOf<E> | ElementOf<E>[], options);\n};\n","import {\n  type InsertNodesOptions,\n  type TEditor,\n  getQueryOptions,\n} from '@udecode/slate';\n\nimport { insertElements } from './insertElements';\n\nexport const insertEmptyElement = <E extends TEditor>(\n  editor: E,\n  type: string,\n  options?: InsertNodesOptions<E>\n) => {\n  insertElements(\n    editor,\n    {\n      children: [{ text: '' }],\n      type,\n    },\n    getQueryOptions(editor, options)\n  );\n};\n","import {\n  type NodeEntryOf,\n  type TEditor,\n  type TElement,\n  getNode,\n  isBlock,\n  moveNodes,\n} from '@udecode/slate';\nimport { Path } from 'slate';\n\nexport interface MoveChildrenOptions<E extends TEditor = TEditor> {\n  /** Parent node of the children to move. */\n  at: NodeEntryOf<E> | Path;\n\n  /** Path where to move the children. */\n  to: Path;\n\n  /**\n   * Start index of the children to move. Example: 1 means children[0] will not\n   * be moved.\n   */\n  fromStartIndex?: number;\n\n  /** Condition for the child to be moved */\n  match?: (entry: NodeEntryOf<E>) => boolean;\n}\n\n/** Move the children of a node to a path. Returns the number of children moved. */\nexport const moveChildren = <E extends TEditor>(\n  editor: E,\n  { at, fromStartIndex = 0, match, to }: MoveChildrenOptions<E>\n) => {\n  let moved = 0;\n  const parentPath = Path.isPath(at) ? at : at[1];\n  const parentNode = Path.isPath(at) ? getNode(editor, parentPath) : at[0];\n\n  if (!parentNode) return moved;\n  if (!isBlock(editor, parentNode)) return moved;\n\n  for (\n    let i = (parentNode.children as TElement[]).length - 1;\n    i >= fromStartIndex;\n    i--\n  ) {\n    const childPath = [...parentPath, i];\n    const childNode = getNode(editor, childPath);\n\n    if (!match || (childNode && match([childNode, childPath]))) {\n      moveNodes(editor, { at: childPath, to });\n      moved++;\n    }\n  }\n\n  return moved;\n};\n","import {\n  type RemoveNodesOptions,\n  type TEditor,\n  removeNodes,\n} from '@udecode/slate';\n\n/** Remove non-empty editor text nodes */\nexport const removeEditorText = <E extends TEditor>(\n  editor: E,\n  { match, ...options }: RemoveNodesOptions<E> = {}\n) => {\n  removeNodes(editor, {\n    at: [],\n    match: (n, p) => {\n      return (n.text as string)?.length > 0 && (!match || match(n, p));\n    },\n    ...options,\n  });\n};\n","import {\n  type GetAboveNodeOptions,\n  type TEditor,\n  type TElement,\n  type TNodeEntry,\n  isElementEmpty,\n} from '@udecode/slate';\n\nimport { getBlockAbove, getPreviousSiblingNode } from '../queries';\n\nexport const removeEmptyPreviousBlock = <E extends TEditor>(\n  editor: E,\n  options: GetAboveNodeOptions<E> = {}\n) => {\n  const entry = getBlockAbove(editor, options);\n\n  if (!entry) return;\n\n  const prevEntry = getPreviousSiblingNode(editor, entry[1]) as\n    | TNodeEntry\n    | undefined;\n\n  if (prevEntry && isElementEmpty(editor, prevEntry[0] as TElement)) {\n    editor.removeNodes({ at: prevEntry[1] });\n  }\n};\n","import {\n  type SetNodesOptions,\n  type TEditor,\n  getMarks,\n  isText,\n  unsetNodes,\n} from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\nimport { Range } from 'slate';\n\nexport interface RemoveMarkOptions<E extends TEditor>\n  extends Omit<SetNodesOptions<E>, 'match' | 'split'> {\n  /** Mark or the array of marks that will be removed */\n  key: string[] | string;\n\n  /** Range where the mark(s) will be removed */\n  at?: Range;\n\n  /**\n   * When location is not a Range, setting this to false can prevent the\n   * onChange event of the editor to fire\n   *\n   * @default true\n   */\n  shouldChange?: boolean;\n}\n\n/** Remove mark and trigger `onChange` if collapsed selection. */\nexport const removeMark = <E extends TEditor>(\n  editor: E,\n  { key, at, shouldChange = true, ...rest }: RemoveMarkOptions<E>\n) => {\n  const selection = at ?? editor.selection;\n  key = castArray(key);\n\n  if (selection) {\n    if (Range.isRange(selection) && Range.isExpanded(selection)) {\n      unsetNodes(editor, key as any as string, {\n        at: selection,\n        match: isText,\n        split: true,\n        ...rest,\n      });\n    } else if (editor.selection) {\n      const marks: any = getMarks(editor) ?? {};\n      key.forEach((k) => {\n        delete marks[k];\n      });\n      editor.marks = marks;\n      shouldChange && editor.onChange();\n    }\n  }\n};\n","import type { Path } from 'slate';\n\nimport {\n  type RemoveNodesOptions,\n  type TEditor,\n  getNodeChildren,\n  removeNodes,\n  withoutNormalizing,\n} from '@udecode/slate';\n\n/** Remove node children. */\nexport const removeNodeChildren = <E extends TEditor>(\n  editor: E,\n  path: Path,\n  options?: Omit<RemoveNodesOptions<E>, 'at'>\n) => {\n  withoutNormalizing(editor, () => {\n    for (const [, childPath] of getNodeChildren(editor, path, {\n      reverse: true,\n    })) {\n      removeNodes(editor, { ...options, at: childPath });\n    }\n  });\n};\n","import { type TEditor, getMarks, removeEditorMark } from '@udecode/slate';\n\n/** Remove selection marks. */\nexport const removeSelectionMark = (editor: TEditor) => {\n  const marks = getMarks(editor);\n\n  if (!marks) return;\n\n  // remove all marks\n  Object.keys(marks).forEach((key) => {\n    removeEditorMark(editor, key);\n  });\n};\n","import {\n  type ElementOrTextOf,\n  type TEditor,\n  insertNodes,\n  removeNodes,\n  withoutNormalizing,\n} from '@udecode/slate';\n\nimport type { ReplaceNodeChildrenOptions } from './replaceNodeChildren';\n\nexport const replaceNode = <\n  N extends ElementOrTextOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  { at, insertOptions, nodes, removeOptions }: ReplaceNodeChildrenOptions<N, E>\n) => {\n  withoutNormalizing(editor, () => {\n    removeNodes(editor, { ...removeOptions, at });\n\n    insertNodes(editor, nodes, {\n      ...insertOptions,\n      at,\n    });\n  });\n};\n","import type { Path } from 'slate';\n\nimport {\n  type ElementOrTextOf,\n  type InsertNodesOptions,\n  type RemoveNodesOptions,\n  type TEditor,\n  insertNodes,\n  withoutNormalizing,\n} from '@udecode/slate';\n\nimport { removeNodeChildren } from './removeNodeChildren';\n\nexport interface ReplaceNodeChildrenOptions<\n  N extends ElementOrTextOf<E>,\n  E extends TEditor = TEditor,\n> {\n  at: Path;\n  nodes: N | N[];\n  insertOptions?: Omit<InsertNodesOptions<E>, 'at'>;\n  removeOptions?: Omit<RemoveNodesOptions<E>, 'at'>;\n}\n\n/** Replace node children: remove then insert. */\nexport const replaceNodeChildren = <\n  N extends ElementOrTextOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  { at, insertOptions, nodes, removeOptions }: ReplaceNodeChildrenOptions<N, E>\n) => {\n  withoutNormalizing(editor, () => {\n    removeNodeChildren(editor, at, removeOptions);\n\n    insertNodes(editor, nodes, {\n      ...insertOptions,\n      at: at.concat([0]),\n    });\n  });\n};\n","import type { Path } from 'slate';\n\nimport { type TEditor, getEndPoint, select } from '@udecode/slate';\n\nimport { getBlockAbove } from '../queries';\n\n/** Select the end point of the block above the selection. */\nexport const selectEndOfBlockAboveSelection = (editor: TEditor) => {\n  const path = getBlockAbove(editor)?.[1];\n\n  path && select(editor, getEndPoint(editor, path as Path));\n};\n","import { type TEditor, type TNodeEntry, setSelection } from '@udecode/slate';\n\nimport { getNodesRange } from '../queries';\n\nexport const selectNodes = (editor: TEditor, nodes: TNodeEntry[]) => {\n  const range = getNodesRange(editor, nodes);\n\n  if (!range) return;\n\n  setSelection(editor, range);\n};\n","import type {\n  ElementOf,\n  SetNodesOptions,\n  TEditor,\n  TNodeProps,\n} from '@udecode/slate';\n\nimport { getBlockAbove } from '../queries';\n\nexport const setBlockAboveNode = <\n  N extends ElementOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  props: Partial<TNodeProps<N>>,\n  options?: Omit<SetNodesOptions<E>, 'at'>\n) => {\n  const at = getBlockAbove(editor)?.[1];\n\n  if (!at) return;\n\n  editor.setNodes(props, {\n    ...options,\n    at: getBlockAbove(editor)![1],\n  } as any);\n};\n\nexport const setBlockAboveTexts = <\n  N extends ElementOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  props: Partial<TNodeProps<N>>,\n  options?: Omit<SetNodesOptions<E>, 'at'>\n) => {\n  setBlockAboveNode(editor, props, { ...options, mode: 'lowest' });\n};\n","import type {\n  ElementOf,\n  GetNodeEntriesOptions,\n  TEditor,\n  TNodeProps,\n} from '@udecode/slate';\n\nimport { getBlocks } from '../queries/getBlocks';\n\nexport const setBlockNodes = <\n  N extends ElementOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  props: Partial<TNodeProps<N>>,\n  options?: GetNodeEntriesOptions<E>\n) => {\n  editor.withoutNormalizing(() => {\n    const blocks = getBlocks(editor, options);\n\n    blocks.forEach(([, path]) => {\n      editor.setNodes<N>(props as any, {\n        at: path,\n      });\n    });\n  });\n};\n","import { type MarksOf, type TEditor, withoutNormalizing } from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\n\nimport { removeMark } from './removeMark';\n\n/** Set marks to selected text. */\nexport const setMarks = <E extends TEditor>(\n  editor: E,\n  marks: MarksOf<E>,\n  clear: string[] | string = []\n) => {\n  if (!editor.selection) return;\n\n  withoutNormalizing(editor, () => {\n    const clears = castArray<string>(clear);\n    removeMark(editor, { key: clears });\n    removeMark(editor, { key: Object.keys(marks) });\n\n    Object.keys(marks).forEach((key) => {\n      editor.addMark(key, (marks as any)[key]);\n    });\n  });\n};\n","import { type TEditor, withoutNormalizing } from '@udecode/slate';\nimport castArray from 'lodash/castArray.js';\n\nimport { isMarkActive } from '../queries';\nimport { removeMark } from './removeMark';\n\nexport interface ToggleMarkOptions {\n  /** The mark key to toggle. */\n  key: string;\n\n  /** Mark keys to clear when adding the mark. */\n  clear?: string[] | string;\n}\n\n/** Add or remove marks in the selection. */\nexport const toggleMark = (\n  editor: TEditor,\n  { key, clear }: ToggleMarkOptions\n) => {\n  if (!editor.selection) return;\n\n  withoutNormalizing(editor, () => {\n    const isActive = isMarkActive(editor, key);\n\n    if (isActive) {\n      editor.removeMark(key);\n\n      return;\n    }\n    if (clear) {\n      const clears = castArray<string>(clear);\n      removeMark(editor, { key: clears });\n    }\n\n    editor.addMark(key, true);\n  });\n};\n","import {\n  type TEditor,\n  type TElement,\n  someNode,\n  unwrapNodes,\n  wrapNodes,\n} from '@udecode/slate';\n\n/** Unwrap if the node type is in selection. Wrap otherwise. */\nexport const toggleWrapNodes = (editor: TEditor, type: string) => {\n  if (someNode(editor, { match: { type } })) {\n    unwrapNodes(editor, { match: { type } });\n  } else {\n    wrapNodes<TElement>(editor, {\n      children: [],\n      type,\n    });\n  }\n};\n","import type { Modify } from '@udecode/utils';\nimport type { Path } from 'slate';\n\nimport {\n  type ElementOf,\n  type TEditor,\n  type TElement,\n  type WrapNodesOptions,\n  getNode,\n  withoutNormalizing,\n  wrapNodes,\n} from '@udecode/slate';\n\nimport { moveChildren } from './moveChildren';\n\n/**\n * Wrap node children into a single element:\n *\n * - Wraps the first child node into the element\n * - Move the other child nodes next to the element children.\n */\nexport const wrapNodeChildren = <\n  N extends ElementOf<E>,\n  E extends TEditor = TEditor,\n>(\n  editor: E,\n  element: N,\n  options: Modify<WrapNodesOptions<E>, { at: Path }>\n) => {\n  const path = options?.at;\n  const node = getNode<TElement>(editor, path);\n\n  if (!node?.children) return;\n\n  withoutNormalizing(editor, () => {\n    const firstChildPath = path.concat([0]);\n\n    wrapNodes(editor, element, {\n      ...options,\n      at: firstChildPath,\n    });\n\n    if (node.children.length < 2) return;\n\n    moveChildren(editor, {\n      at: path,\n      fromStartIndex: 1,\n      to: firstChildPath.concat([1]),\n    });\n  });\n};\n","import type { TDescendant } from '@udecode/slate';\n\nexport const createDocumentNode = (\n  type = 'p',\n  text = '',\n  remaining: TDescendant[] = []\n): TDescendant[] => [\n  {\n    children: [\n      {\n        children: [{ text }],\n        type,\n      },\n      ...remaining,\n    ],\n  } as any,\n];\n","import type { TElement } from '@udecode/slate';\n\nexport const createNode = (type = 'p', text = ''): TElement => ({\n  children: [{ text }],\n  type,\n});\n"],"mappings":"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","names":["last","getNodeEntry","getNodeTexts","Path","isAncestor","getLastChild","Path","Range","Range","Path","_a","Path","Range","getPointBefore","Path","getPointBefore","Path","getNodeEntries","getPreviousNode","last","getPoint","getPoint","getStartPoint","getStartPoint","nodes","getEditorString","isText","isText","getEndPoint","isEndPoint","Path","getEditorString","getPointAfter","getRange","Path","Range","Range","Path","Path","Range","isEndPoint","isEndPoint","isExpanded","getNode","isText","getEditorString","getPointBefore","getRange","match","castArray","castArray","Path","getNode","isBlock","Path","match","match","_a","isElementEmpty","isElementEmpty","getMarks","isText","castArray","Range","_a","castArray","Range","isText","getMarks","removeNodes","removeNodes","getMarks","insertNodes","removeNodes","withoutNormalizing","withoutNormalizing","removeNodes","insertNodes","insertNodes","withoutNormalizing","withoutNormalizing","insertNodes","getEndPoint","getEndPoint","withoutNormalizing","castArray","withoutNormalizing","castArray","withoutNormalizing","castArray","withoutNormalizing","castArray","someNode","getNode","withoutNormalizing","wrapNodes","getNode","withoutNormalizing","wrapNodes"]}