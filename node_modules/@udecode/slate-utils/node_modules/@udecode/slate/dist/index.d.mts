import { UnknownObject, Simplify, UnionToIntersection, Modify } from '@udecode/utils';
import * as slate from 'slate';
import { Path, Location, Range, Selection, Span, DecoratedRange, Editor, Point, EditorLevelsOptions, NodeAncestorsOptions, NodeChildrenOptions, NodeDescendantsOptions, NodeElementsOptions, NodeLevelsOptions, NodeTextsOptions as NodeTextsOptions$1, NodeNodesOptions, EditorNextOptions, EditorUnhangRangeOptions, EditorNodesOptions, EditorNodeOptions, EditorParentOptions, EditorPathOptions, EditorPointOptions, EditorAfterOptions, EditorBeforeOptions, EditorPositionsOptions, EditorPreviousOptions, EditorVoidOptions, EditorNormalizeOptions, Transforms, Operation, BaseEditor } from 'slate';
import { HistoryEditor as HistoryEditor$1 } from 'slate-history';
import { EditorPathRefOptions, EditorPointRefOptions, EditorRangeRefOptions, EditorDirectedDeletionOptions, EditorFragmentDeletionOptions, EditorAboveOptions, EditorStringOptions, EditorLeafOptions } from 'slate/dist/interfaces/editor';
import { SelectionCollapseOptions, SelectionMoveOptions, SelectionSetPointOptions } from 'slate/dist/interfaces/transforms/selection';
import { TextDeleteOptions, TextInsertFragmentOptions, TextInsertTextOptions } from 'slate/dist/interfaces/transforms/text';

/**
 * `Text` objects represent the nodes that contain the actual text content of a
 * Slate document along with any formatting properties. They are always leaf
 * nodes in the document tree as they cannot contain any children.
 */
type TText = {
    text: string;
} & UnknownObject;
/** A utility type to get all the text node types from a root node type. */
type TextOf<N extends TNode> = TEditor extends N ? TText : TElement extends N ? TText : N extends TEditor ? TextOf<N['children'][number]> : N extends TElement ? Extract<N['children'][number], TText> | TextOf<N['children'][number]> : N extends TText ? N : never;
/** A utility type to get all the mark types from a root node type. */
type MarksOf<N extends TNode> = Simplify<UnionToIntersection<TNodeProps<TextOf<N>>>>;
type MarkKeysOf<N extends TNode> = {} extends MarksOf<N> ? unknown : keyof MarksOf<N>;

type TNode = TEditor | TElement | TText;
/** A utility type to get all the node types from a root node type. */
type NodeOf<N extends TNode> = ElementOf<N> | N | TextOf<N>;
/** Convenience type for returning the props of a node. */
type TNodeProps<N extends TNode> = N extends TEditor ? Omit<N, 'children'> : N extends TElement ? Omit<N, 'children'> : Omit<N, 'text'>;
/** A helper type for narrowing matched nodes with a predicate. */
type TNodeMatch<N extends TNode = TNode> = ((node: N, path: Path) => boolean) | ((node: N, path: Path) => node is N);

/**
 * `Element` objects are a type of node in a Slate document that contain other
 * element nodes or text nodes. They can be either "blocks" or "inlines"
 * depending on the Slate editor's configuration.
 */
type TElement = {
    children: TDescendant[];
    type: string;
} & UnknownObject;
/** Element or text of an editor. */
type ElementOrTextOf<E extends TEditor> = ElementOf<E> | TextOf<E>;
/**
 * `ElementEntry` objects refer to an `Element` and the `Path` where it can be
 * found inside a root node.
 */
/** A utility type to get all the element nodes type from a root node. */
type ElementOf<N extends TNode> = TEditor extends N ? TElement : TElement extends N ? TElement : N extends TEditor ? ElementOf<N['children'][number]> | Extract<N['children'][number], TElement> : N extends TElement ? ElementOf<N['children'][number]> | Extract<N['children'][number], TElement> | N : never;

/**
 * The `Descendant` union type represents nodes that are descendants in the
 * tree. It is returned as a convenience in certain cases to narrow a value
 * further than the more generic `Node` union.
 */
type TDescendant = TElement | TText;
/** A utility type to get all the descendant node types from a root node type. */
type DescendantOf<N extends TNode> = N extends TEditor ? ElementOf<N> | TextOf<N> : N extends TElement ? ElementOf<N['children'][number]> | TextOf<N> : never;
/** A utility type to get the child node types from a root node type. */
type ChildOf<N extends TNode, I extends number = number> = N extends TEditor ? N['children'][I] : N extends TElement ? N['children'][I] : never;
declare const isDescendant: (value: any) => value is TDescendant;

type TLocation = Location;
type TPath = Path;
type TRange = Range;
type TSelection = Selection;
type TSpan = Span;
type TDecoratedRange = DecoratedRange;

type TInsertNodeOperation<N extends TDescendant = TDescendant> = {
    [key: string]: unknown;
    node: N;
    path: TPath;
    type: 'insert_node';
};
type TInsertTextOperation = {
    [key: string]: unknown;
    offset: number;
    path: TPath;
    text: string;
    type: 'insert_text';
};
type TMergeNodeOperation = {
    [key: string]: unknown;
    path: TPath;
    position: number;
    properties: object;
    type: 'merge_node';
};
type TMoveNodeOperation = {
    [key: string]: unknown;
    newPath: TPath;
    path: TPath;
    type: 'move_node';
};
type TRemoveNodeOperation<N extends TDescendant = TDescendant> = {
    [key: string]: unknown;
    node: N;
    path: TPath;
    type: 'remove_node';
};
type TRemoveTextOperation = {
    [key: string]: unknown;
    offset: number;
    path: TPath;
    text: string;
    type: 'remove_text';
};
type TSetNodeOperation = {
    [key: string]: unknown;
    newProperties: object;
    path: TPath;
    properties: object;
    type: 'set_node';
};
type TSetSelectionOperation = {
    [key: string]: unknown;
    newProperties: Partial<TRange>;
    properties: Partial<TRange>;
    type: 'set_selection';
} | {
    [key: string]: unknown;
    newProperties: TRange;
    properties: null;
    type: 'set_selection';
} | {
    [key: string]: unknown;
    newProperties: null;
    properties: TRange;
    type: 'set_selection';
};
type TSplitNodeOperation = {
    [key: string]: unknown;
    path: TPath;
    position: number;
    properties: object;
    type: 'split_node';
};
type TNodeOperation<N extends TDescendant = TDescendant> = TInsertNodeOperation<N> | TMergeNodeOperation | TMoveNodeOperation | TRemoveNodeOperation<N> | TSetNodeOperation | TSplitNodeOperation;
type TSelectionOperation = TSetSelectionOperation;
type TTextOperation = TInsertTextOperation | TRemoveTextOperation;
/**
 * `Operation` objects define the low-level instructions that Slate editors use
 * to apply changes to their internal state. Representing all changes as
 * operations is what allows Slate editors to easily implement history,
 * collaboration, and other features.
 */
type TOperation<N extends TDescendant = TDescendant> = TNodeOperation<N> | TSelectionOperation | TTextOperation;

/**
 * The `Ancestor` union type represents nodes that are ancestors in the tree. It
 * is returned as a convenience in certain cases to narrow a value further than
 * the more generic `Node` union.
 */
type TAncestor = TEditor | TElement;
/** A utility type to get all the ancestor node types from a root node type. */
type AncestorOf<N extends TNode> = TEditor extends N ? TEditor | TElement : TElement extends N ? TElement : N extends TEditor ? ElementOf<N['children'][number]> | N | N['children'][number] : N extends TElement ? ElementOf<N> | N : never;

/**
 * `TNodeEntry` objects are returned when iterating over the nodes in a Slate
 * document tree. They consist of the node and its `Path` relative to the root
 * node in the document.
 */
type TNodeEntry<N extends TNode = TNode> = [N, Path];
/** Node entry from an editor. */
type NodeEntryOf<E extends TEditor> = TNodeEntry<NodeOf<E>>;
/** Element entry from a node. */
type TElementEntry<N extends TNode = TNode> = TNodeEntry<ElementOf<N>>;
/** Element entry of a value. */
type ElementEntryOf<E extends TEditor> = TNodeEntry<ElementOf<E>>;
/** Text node entry from a node. */
type TTextEntry<N extends TNode = TNode> = TNodeEntry<TextOf<N>>;
/** Text node entry of a value. */
type TextEntryOf<E extends TEditor> = TNodeEntry<TextOf<E>>;
/** Ancestor entry from a node. */
type TAncestorEntry<N extends TNode = TNode> = TNodeEntry<AncestorOf<N>>;
/** Ancestor entry from an editor. */
type AncestorEntryOf<E extends TEditor> = TAncestorEntry<E>;
/** Descendant entry from a node. */
type TDescendantEntry<N extends TNode = TNode> = TNodeEntry<DescendantOf<N>>;
/** Descendant entry of a value. */
type DescendantEntryOf<E extends TEditor> = TNodeEntry<DescendantOf<E>>;
/** Child node entry from a node. */
type TNodeChildEntry<N extends TNode = TNode> = TNodeEntry<ChildOf<N>>;

type Value = TElement[];
/** A helper type for getting the value of an editor. */
type ValueOf<E extends TEditor> = E['children'];
type TEditor<V extends Value = Value> = {
    hasEditableTarget: (editor: TEditor<V>, target: EventTarget | null) => target is Node;
    hasSelectableTarget: (editor: TEditor<V>, target: EventTarget | null) => boolean;
    isTargetInsideNonReadonlyVoid: (editor: TEditor<V>, target: EventTarget | null) => boolean;
    setFragmentData: (data: DataTransfer, originEvent?: 'copy' | 'cut' | 'drag') => void;
    hasRange: (editor: TEditor<V>, range: Range) => boolean;
    hasTarget: (editor: TEditor<V>, target: EventTarget | null) => target is Node;
    insertData: (data: DataTransfer) => void;
    insertFragmentData: (data: DataTransfer) => boolean;
    insertTextData: (data: DataTransfer) => boolean;
} & Modify<Editor, {
    id: any;
    apply: <N extends TDescendant>(operation: TOperation<N>) => void;
    children: V;
    getDirtyPaths: <N extends TDescendant>(operation: TOperation<N>) => Path[];
    getFragment: () => TDescendant[];
    insertFragment: <N extends TDescendant>(fragment: N[]) => void;
    insertNode: <N extends TDescendant>(node: N) => void;
    isInline: <N extends TElement>(element: N) => boolean;
    isVoid: <N extends TElement>(element: N) => boolean;
    markableVoid: <N extends TElement>(element: N) => boolean;
    normalizeNode: <N extends TNode>(entry: TNodeEntry<N>, options?: {
        operation?: TOperation;
    }) => void;
    marks: Record<string, any> | null;
    operations: TOperation[];
}> & Pick<HistoryEditor$1, 'history' | 'redo' | 'undo' | 'writeHistory'> & UnknownObject;

declare const createTEditor: <V extends Value>() => TEditor<V>;

/**
 * Add a custom property to the leaf text nodes in the current selection.
 *
 * If the selection is currently collapsed, the marks will be added to the
 * `editor.marks` property instead, and applied when text is inserted next.
 */
declare const addMark: (editor: TEditor, key: string, value: any) => void;

/**
 * Create a mutable ref for a `Path` object, which will stay in sync as new
 * operations are applied to the editor.
 */
declare const createPathRef: (editor: TEditor, at: Path, options?: EditorPathRefOptions) => slate.PathRef;

/**
 * Create a mutable ref for a `Point` object, which will stay in sync as new
 * operations are applied to the editor.
 */
declare const createPointRef: (editor: TEditor, point: Point, options?: EditorPointRefOptions) => slate.PointRef;

/**
 * Create a mutable ref for a `Range` object, which will stay in sync as new
 * operations are applied to the editor.
 */
declare const createRangeRef: (editor: TEditor, range: Range, options?: EditorRangeRefOptions) => slate.RangeRef;

/** Delete content in the editor backward from the current selection. */
declare const deleteBackward: (editor: TEditor, options?: EditorDirectedDeletionOptions) => void;

/** Delete content in the editor forward from the current selection. */
declare const deleteForward: (editor: TEditor, options?: EditorDirectedDeletionOptions) => void;

/** Delete the content in the current selection. */
declare const deleteFragment: (editor: TEditor, options?: EditorFragmentDeletionOptions) => void;

declare const deleteMerge: (editor: TEditor, options?: {
    at?: Location;
    distance?: number;
    hanging?: boolean;
    reverse?: boolean;
    test?: any;
    unit?: "block" | "character" | "line" | "word";
    voids?: boolean;
}) => void;

type PredicateObj = Record<string, any[] | any>;
type PredicateFn<T extends TNode> = (obj: T, path: TPath) => boolean;
type Predicate<T extends TNode> = PredicateFn<T> | PredicateObj;
/**
 * Match the object with a predicate object or function. If predicate is:
 *
 * - Object: every predicate key/value should be in obj.
 * - Function: it should return true.
 */
declare const match: <T extends TNode>(obj: T, path: TPath, predicate?: Predicate<T>) => boolean;
/**
 * Extended query options for slate queries:
 *
 * - `match` can be an object predicate where one of the values should include the
 *   node value. Example: { type: ['1', '2'] } will match the nodes having one
 *   of these 2 types.
 */
declare const getQueryOptions: <E extends TEditor>(editor: E, options?: any) => any;
type ENodeMatch<N extends TNode> = Predicate<N>;
interface ENodeMatchOptions<E extends TEditor = TEditor> {
    block?: boolean;
    match?: ENodeMatch<NodeOf<E>>;
}

type GetAboveNodeOptions<E extends TEditor = TEditor> = Modify<NonNullable<EditorAboveOptions<TAncestor>>, ENodeMatchOptions<E>>;
/** Get the ancestor above a location in the document. */
declare const getAboveNode: <N extends AncestorOf<E>, E extends TEditor = TEditor>(editor: E, options?: GetAboveNodeOptions<E>) => TNodeEntry<N> | undefined;

/** Get the start and end points of a location. */
declare const getEdgePoints: (editor: TEditor, at: Location) => [slate.BasePoint, slate.BasePoint];

/**
 * Get the text string content of a location.
 *
 * Note: by default the text of void nodes is considered to be an empty string,
 * regardless of content, unless you pass in true for the voids option
 */
declare const getEditorString: (editor: TEditor, at: Location | null | undefined, options?: EditorStringOptions) => string;

/** Get the end point of a location. */
declare const getEndPoint: (editor: TEditor, at: Location) => slate.BasePoint;

/** Get the first node at a location. */
declare const getFirstNode: <E extends TEditor>(editor: E, at: Location) => NodeEntryOf<E>;

/** Get the fragment at a location. */
declare const getFragment: <E extends TEditor>(editor: E, at: Location) => ElementOrTextOf<E>[];

/** Get the last node at a location. */
declare const getLastNode: <E extends TEditor>(editor: E, at: Location) => NodeEntryOf<E>;

/** Get the leaf text node at a location. */
declare const getLeafNode: <E extends TEditor>(editor: E, at: Location, options?: EditorLeafOptions) => TextEntryOf<E>;

type GetLevelsOptions<E extends TEditor = TEditor> = Modify<NonNullable<EditorLevelsOptions<TNode>>, {
    match?: TNodeMatch<NodeOf<E>>;
}>;
/** Iterate through all of the levels at a location. */
declare const getLevels: <N extends NodeOf<E>, E extends TEditor = TEditor>(editor: E, options?: GetLevelsOptions<E>) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the marks that would be added to text at the current selection. */
declare const getMarks: <E extends TEditor>(editor: E) => MarksOf<E> | null;

/** Get an entry for the common ancesetor node of two paths. */
declare const getCommonNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path, another: Path) => TNodeEntry<N>;

/**
 * Get the descendant node referred to by a specific path. If the path is an
 * empty array, it refers to the root node itself. If the node is not found,
 * return null. Based on Slate get and has, performance optimization without
 * overhead of stringify on throwing
 */
declare const getNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path) => N | null;

/** Get the node at a specific path, asserting that it's an ancestor node. */
declare const getNodeAncestor: <N extends AncestorOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/**
 * Return a generator of all the ancestor nodes above a specific path.
 *
 * By default the order is bottom-up, from lowest to highest ancestor in the
 * tree, but you can pass the `reverse: true` option to go top-down.
 */
declare const getNodeAncestors: <N extends AncestorOf<R>, R extends TNode = TNode>(root: R, path: Path, options?: NodeAncestorsOptions) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the child of a node at a specific index. */
declare const getNodeChild: <N extends ChildOf<R, I>, R extends TNode = TNode, I extends number = number>(root: R, index: I) => N;

/** Iterate over the children of a node at a specific path. */
declare const getNodeChildren: <N extends ChildOf<R>, R extends TNode = TNode>(root: R, path: Path, options?: NodeChildrenOptions) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the node at a specific path, asserting that it's a descendant node. */
declare const getNodeDescendant: <N extends DescendantOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/** Return a generator of all the descendant node entries inside a root node. */
declare const getNodeDescendants: <N extends DescendantOf<R>, R extends TNode = TNode>(root: R, options?: Modify<NonNullable<NodeDescendantsOptions>, {
    pass?: (node: TDescendantEntry<N>) => boolean;
}>) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Return a generator of all the element nodes inside a root node. Each
 * iteration will return an `ElementEntry` tuple consisting of `[Element,
 * Path]`. If the root node is an element it will be included in the iteration
 * as well.
 */
declare const getNodeElements: <N extends ElementOf<R>, R extends TNode = TNode>(root: R, options?: Modify<NonNullable<NodeElementsOptions>, {
    pass?: (node: TElementEntry<N>) => boolean;
}>) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the first node entry in a root node from a path. */
declare const getNodeFirstNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path) => TNodeEntry<N>;

/** Get the sliced fragment represented by a range inside a root node. */
declare const getNodeFragment: <N extends ElementOf<R> | TextOf<R>, R extends TNode = TNode>(root: R, range: Range) => N[];

/** Get the last node entry in a root node from a path. */
declare const getNodeLastNode: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path) => TNodeEntry<N>;

/** Get the node at a specific path, ensuring it's a leaf text node. */
declare const getNodeLeaf: <N extends TextOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/**
 * Return a generator of the in a branch of the tree, from a specific path.
 *
 * By default the order is top-down, from lowest to highest node in the tree,
 * but you can pass the `reverse: true` option to go bottom-up.
 */
declare const getNodeLevels: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, path: Path, options?: NodeLevelsOptions) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the parent of a node at a specific path. */
declare const getNodeParent: <N extends AncestorOf<R>, R extends TNode = TNode>(root: R, path: Path) => N;

/** Extract the custom properties from a node. */
declare const getNodeProps: <N extends TNode>(node: N) => TNodeProps<N>;

/**
 * Get the concatenated text string of a node's content.
 *
 * Note that this will not include spaces or line breaks between block nodes. It
 * is not a user-facing string, but a string for performing offset-related
 * computations for a node.
 */
declare const getNodeString: (node: TNode) => string;

type NodeTextsOptions<N extends TextOf<R>, R extends TNode = TNode> = Modify<NonNullable<NodeTextsOptions$1>, {
    pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;
}>;
/** Return a generator of all leaf text nodes in a root node. */
declare const getNodeTexts: <N extends TextOf<R>, R extends TNode = TNode>(root: R, options?: NodeTextsOptions<N, R>) => Generator<TNodeEntry<N>, void, undefined>;

/**
 * Return a generator of all the node entries of a root node. Each entry is
 * returned as a `[Node, Path]` tuple, with the path referring to the node's
 * position inside the root node.
 */
declare const getNodes: <N extends NodeOf<R>, R extends TNode = TNode>(root: R, options?: Modify<NonNullable<NodeNodesOptions>, {
    pass?: (entry: TNodeEntry<NodeOf<N>>) => boolean;
}>) => Generator<TNodeEntry<N>, void, undefined>;

/** Check if a descendant node exists at a specific path. */
declare const hasNode: (root: TNode, path: Path) => boolean;

declare const hasSingleChild: <N extends TNode>(node: N) => boolean;

/** Check if a value implements the 'Ancestor' interface. */
declare const isAncestor: (value: any) => value is TAncestor;

/** Check if a value implements the `Node` interface. */
declare const isNode: (value: any) => value is TNode;

/** Check if a value is a list of `Node` objects. */
declare const isNodeList: (value: any) => value is TNode[];

/** Check if a node matches a set of props. */
declare const nodeMatches: (node: TNode, props: object) => boolean;

type GetNextNodeOptions<E extends TEditor = TEditor> = Modify<NonNullable<EditorNextOptions<TDescendant>>, {
    match?: TNodeMatch<NodeOf<E>>;
}>;
/** Get the matching node in the branch of the document after a location. */
declare const getNextNode: <N extends NodeOf<E>, E extends TEditor = TEditor>(editor: E, options?: GetNextNodeOptions<E>) => TNodeEntry<N> | undefined;

type UnhangRangeOptions = {
    unhang?: boolean;
} & EditorUnhangRangeOptions;
/**
 * Convert a range into a non-hanging one if:
 *
 * - `unhang` is true,
 * - `at` (default: selection) is a range.
 */
declare const unhangRange: <E extends TEditor, R extends Path | Point | Range | Span | null | undefined>(editor: E, range: R, options?: UnhangRangeOptions) => R;

type GetNodeEntriesOptions<E extends TEditor = TEditor> = Modify<NonNullable<EditorNodesOptions<TNode>>, ENodeMatchOptions<E>> & UnhangRangeOptions;
/** Iterate through all of the nodes in the Editor. */
declare const getNodeEntries: <N extends NodeOf<E>, E extends TEditor = TEditor>(editor: E, options?: GetNodeEntriesOptions<E>) => Generator<TNodeEntry<N>, void, undefined>;

/** Get the node at a location. */
declare const getNodeEntry: <N extends NodeOf<E>, E extends TEditor = TEditor>(editor: E, at: Location, options?: EditorNodeOptions) => TNodeEntry<N> | undefined;

/** Get the parent node of a location. Returns undefined if there is no parent. */
declare const getParentNode: <N extends AncestorOf<E>, E extends TEditor = TEditor>(editor: E, at: Location, options?: EditorParentOptions) => TNodeEntry<N> | undefined;

/** Get the path of a location. */
declare const getPath: (editor: TEditor, at: Location, options?: EditorPathOptions) => slate.Path;

/** Get the set of currently tracked path refs of the editor. */
declare const getPathRefs: (editor: TEditor) => Set<slate.PathRef>;

/** Get the start or end point of a location. */
declare const getPoint: (editor: TEditor, at: Location, options?: EditorPointOptions) => slate.BasePoint;

/** Get the point after a location. */
declare const getPointAfter: (editor: TEditor, at: Location, options?: EditorAfterOptions) => slate.BasePoint | undefined;

/** Get the point before a location. */
declare const getPointBefore: (editor: TEditor, at: Location, options?: EditorBeforeOptions) => slate.BasePoint | undefined;

/** Get the set of currently tracked point refs of the editor. */
declare const getPointRefs: (editor: TEditor) => Set<slate.PointRef>;

/**
 * Iterate through all of the positions in the document where a `Point` can be
 * placed.
 *
 * By default it will move forward by individual offsets at a time, but you can
 * pass the `unit: 'character'` option to moved forward one character, word, or
 * line at at time.
 *
 * Note: By default void nodes are treated as a single point and iteration will
 * not happen inside their content unless you pass in true for the voids option,
 * then iteration will occur.
 */
declare const getPositions: (editor: TEditor, options?: EditorPositionsOptions) => Generator<slate.BasePoint, void, undefined>;

type GetPreviousNodeOptions<E extends TEditor = TEditor> = Modify<NonNullable<EditorPreviousOptions<TNode>>, {
    match?: TNodeMatch<NodeOf<E>>;
}>;
/** Get the matching node in the branch of the document before a location. */
declare const getPreviousNode: <N extends NodeOf<E>, E extends TEditor = TEditor>(editor: E, options?: GetPreviousNodeOptions<E>) => TNodeEntry<N> | undefined;

/** Get a range of a location. */
declare const getRange: (editor: TEditor, at: Location, to?: Location) => slate.BaseRange;

/** Get the set of currently tracked range refs of the editor. */
declare const getRangeRefs: (editor: TEditor) => Set<slate.RangeRef>;

/** Get the start point of a location. */
declare const getStartPoint: (editor: TEditor, at: Location) => slate.BasePoint;

/** Match a void node in the current branch of the editor. */
declare const getVoidNode: <N extends ElementOf<E>, E extends TEditor = TEditor>(editor: E, options?: EditorVoidOptions) => TNodeEntry<N> | undefined;

/** Check if a node has block children. */
declare const hasBlocks: (editor: TEditor, element: TElement) => boolean;

/** Check if a node has inline and text children. */
declare const hasInlines: (editor: TEditor, element: TElement) => boolean;

/** Check if a node has text children. */
declare const hasTexts: (editor: TEditor, element: TElement) => boolean;

/**
 * Insert a block break at the current selection.
 *
 * If the selection is currently expanded, it will be deleted first.
 */
declare const insertBreak: (editor: TEditor) => void;

/**
 * Insert a node at the current selection.
 *
 * If the selection is currently expanded, it will be deleted first.
 */
declare const insertNode: <E extends TEditor>(editor: E, node: ElementOrTextOf<E> | ElementOrTextOf<E>[]) => void;

/** Check if a value is a block `Element` object. */
declare const isBlock: (editor: TEditor, value: any) => boolean;

/** Check if a point is an edge of a location. */
declare const isEdgePoint: (editor: TEditor, point: Point, at: Location) => boolean;

/** Check if a value is an `Editor` object. */
declare const isEditor: (value: any) => value is TEditor;

/** Check if the editor is currently normalizing after each operation. */
declare const isEditorNormalizing: (editor: TEditor) => boolean;

/** Check if an element is empty, accounting for void nodes. */
declare const isElementEmpty: (editor: TEditor, element: TElement) => boolean;

/**
 * Check if a point is the end point of a location. If point is null, return
 * false.
 */
declare const isEndPoint: (editor: TEditor, point: Point | null | undefined, at: Location) => boolean;

/** Check if a value is an inline `Element` object. */
declare const isInline: (editor: TEditor, value: any) => boolean;

/** Check if a value is a markable void `Element` object. */
declare const isMarkableVoid: (editor: TEditor, value: any) => boolean;

/**
 * Check if a point is the start point of a location. If point is null, return
 * false.
 */
declare const isStartPoint: (editor: TEditor, point: Point | null | undefined, at: Location) => boolean;

/** Check if a value is a void `Element` object. */
declare const isVoid: (editor: TEditor, value: any) => boolean;

/** Normalize any dirty objects in the editor. */
declare const normalizeEditor: (editor: TEditor, options?: EditorNormalizeOptions) => void;

/**
 * Remove a custom property from all of the leaf text nodes in the current
 * selection.
 *
 * If the selection is currently collapsed, the removal will be stored on
 * `editor.marks` and applied to the text inserted next.
 */
declare const removeEditorMark: (editor: TEditor, key: string) => void;

/**
 * Call a function, deferring normalization until after it completes
 *
 * @returns True if normalized.
 */
declare const withoutNormalizing: (editor: TEditor, fn: () => boolean | void) => boolean;

/**
 * Check if an element matches set of properties.
 *
 * Note: this checks custom properties, and it does not ensure that any children
 * are equivalent.
 */
declare const elementMatches: (element: TElement, props: object) => boolean;

/** Check if a value implements the 'Element' interface. */
declare const isElement: (value: any) => value is TElement;

/** Check if a value is an array of `Element` objects. */
declare const isElementList: (value: any) => value is TElement[];

/** {@link HistoryEditor.isHistoryEditor} */
declare const isHistoryEditor: (value: any) => value is TEditor;

/** {@link HistoryEditor.isMerging} */
declare const isHistoryMerging: (editor: TEditor) => boolean | undefined;

/** {@link HistoryEditor.isSaving} */
declare const isHistorySaving: (editor: TEditor) => boolean | undefined;

/** {@link HistoryEditor.withMerging} */
declare const withMerging: (editor: TEditor, fn: () => void) => void;

/** {@link HistoryEditor.withMerging} */
declare const withNewBatch: (editor: TEditor, fn: () => void) => void;

/** {@link HistoryEditor.withoutMerging} */
declare const withoutMergingHistory: (editor: TEditor, fn: () => void) => void;

/** {@link HistoryEditor.withoutSaving} */
declare const withoutSavingHistory: (editor: TEditor, fn: () => void) => void;

/** See {@link Range.isCollapsed}. Return false if `range` is not defined. */
declare const isCollapsed: (range?: Range | null) => boolean;

/** See {@link Range.isExpanded}. Return false if `range` is not defined. */
declare const isExpanded: (range?: Range | null) => boolean;

/** Check if a value implements the `Text` interface. */
declare const isText: (value: any) => value is TText;

/** Check if a value is a list of `Text` objects. */
declare const isTextList: (value: any) => value is TText[];

/** Check if two text nodes are equal. */
declare const textEquals: (text: TText, another: TText) => boolean;

/**
 * Check if an text matches set of properties.
 *
 * Note: this is for matching custom properties, and it does not ensure that the
 * `text` property are two nodes equal.
 */
declare const textMatches: <T extends TText>(text: T, props: object) => boolean;

/** Collapse the selection. */
declare const collapseSelection: (editor: TEditor, options?: SelectionCollapseOptions) => void;

/** Delete content in the editor. */
declare const deleteText: (editor: TEditor, options?: TextDeleteOptions) => void;

/** Unset the selection. */
declare const deselect: (editor: TEditor) => void;

/** Insert a fragment at a specific location in the editor. */
declare const insertFragment: <N extends ElementOrTextOf<E>, E extends TEditor = TEditor>(editor: E, fragment: N[], options?: TextInsertFragmentOptions) => void;

interface NodeMatchOption<E extends TEditor> {
    match?: TNodeMatch<NodeOf<E>>;
}

/** Filter nodes. */
interface QueryNodeOptions {
    /** List of types that are valid. If empty or undefined - allow all. */
    allow?: string[] | string | null;
    /** List of types that are invalid. */
    exclude?: string[] | string | null;
    /** Query the node entry. */
    filter?: <N extends TNode>(entry: TNodeEntry<N>) => boolean;
    /** Valid path levels. */
    level?: number[] | number | null;
    /** Paths above that value are invalid. */
    maxLevel?: number | null;
}

/** Query the editor state. */
interface QueryEditorOptions<E extends TEditor = TEditor> extends Pick<QueryNodeOptions, 'allow' | 'exclude'> {
    /** Location from where to lookup the node types (bottom-up) */
    at?: Location;
    /** Query the editor. */
    filter?: (editor: E) => boolean;
    /** When the selection is at the end of the block above. */
    selectionAtBlockEnd?: boolean;
    /** When the selection is at the start of the block above. */
    selectionAtBlockStart?: boolean;
}

type InsertNodesOptions<E extends TEditor = TEditor> = {
    /**
     * Insert the nodes after the currect block. Does not apply if the removeEmpty
     * option caused the current block to be removed.
     */
    nextBlock?: boolean;
    /**
     * Remove the currect block if empty before inserting. Only applies to
     * paragraphs by default, but can be customized by passing a QueryNodeOptions
     * object.
     */
    removeEmpty?: QueryNodeOptions | boolean;
} & Modify<NonNullable<Parameters<typeof Transforms.insertNodes>[2]>, NodeMatchOption<E>>;
/** Insert nodes at a specific location in the Editor. */
declare const insertNodes: <N extends ElementOrTextOf<E>, E extends TEditor = TEditor>(editor: E, nodes: N | N[], { nextBlock, removeEmpty, ...options }?: InsertNodesOptions<E>) => void;

/** Insert a string of text in the Editor. */
declare const insertText: (editor: TEditor, text: string, options?: TextInsertTextOptions) => void;

type LiftNodesOptions<E extends TEditor = TEditor> = Modify<NonNullable<Parameters<typeof Transforms.liftNodes>[1]>, NodeMatchOption<E>>;
/**
 * Lift nodes at a specific location upwards in the document tree, splitting
 * their parent in two if necessary.
 */
declare const liftNodes: <E extends TEditor>(editor: E, options?: LiftNodesOptions<E>) => void;

type MergeNodesOptions<E extends TEditor = TEditor> = {
    /**
     * Default: if the node isn't already the next sibling of the previous node,
     * move it so that it is before merging.
     */
    mergeNode?: (editor: E, options: {
        at: Path;
        to: Path;
    }) => void;
    /**
     * Default: if there was going to be an empty ancestor of the node that was
     * merged, we remove it from the tree.
     */
    removeEmptyAncestor?: (editor: E, options: {
        at: Path;
    }) => void;
} & Modify<NonNullable<Parameters<typeof Transforms.mergeNodes>[1]>, NodeMatchOption<E>>;
/**
 * Merge a node at a location with the previous node of the same depth, removing
 * any empty containing nodes after the merge if necessary.
 */
declare const mergeNodes: <E extends TEditor>(editor: E, options?: MergeNodesOptions<E>) => void;

type MoveNodesOptions<E extends TEditor = TEditor> = Modify<NonNullable<Parameters<typeof Transforms.moveNodes>[1]>, NodeMatchOption<E>>;
/** Move the nodes at a location to a new location. */
declare const moveNodes: <E extends TEditor>(editor: E, options?: MoveNodesOptions<E>) => void;

/** Move the selection's point forward or backward. */
declare const moveSelection: (editor: TEditor, options?: SelectionMoveOptions) => void;

type RemoveNodesOptions<E extends TEditor = TEditor> = Modify<NonNullable<Parameters<typeof Transforms.removeNodes>[1]>, NodeMatchOption<E>>;
/** Remove the nodes at a specific location in the document. */
declare const removeNodes: <E extends TEditor>(editor: E, options?: RemoveNodesOptions<E>) => void;

/** Set the selection to a new value. */
declare const select: (editor: TEditor, target: Location) => void;

type SetNodesOptions<E extends TEditor = TEditor> = Modify<NonNullable<Parameters<typeof Transforms.setNodes>[2]>, NodeMatchOption<E>>;
/** Set new properties on the nodes at a location. */
declare const setNodes: <N extends NodeOf<E>, E extends TEditor = TEditor>(editor: E, props: Partial<TNodeProps<N>>, options?: SetNodesOptions<E>) => void;

/** Set new properties on one of the selection's points. */
declare const setPoint: (editor: TEditor, props: Partial<Point>, options?: SelectionSetPointOptions) => void;

/** Set new properties on the selection. */
declare const setSelection: (editor: TEditor, props: Partial<Range>) => void;

type SplitNodesOptions<E extends TEditor = TEditor> = Modify<NonNullable<Parameters<typeof Transforms.splitNodes>[1]>, NodeMatchOption<E>>;
/** Split the nodes at a specific location. */
declare const splitNodes: <E extends TEditor>(editor: E, options?: SplitNodesOptions<E>) => void;

type UnsetNodesOptions<E extends TEditor = TEditor> = Modify<NonNullable<Parameters<typeof Transforms.unsetNodes>[2]>, NodeMatchOption<E>>;
/** Unset properties on the nodes at a location. */
declare const unsetNodes: <N extends NodeOf<E>, E extends TEditor = TEditor>(editor: E, props: (keyof TNodeProps<N>)[] | keyof TNodeProps<N>, options?: UnsetNodesOptions<E>) => void;

type UnwrapNodesOptions<E extends TEditor = TEditor> = Modify<NonNullable<Parameters<typeof Transforms.unwrapNodes>[1]>, ENodeMatchOptions<E>>;
/**
 * Unwrap the nodes at a location from a parent node, splitting the parent if
 * necessary to ensure that only the content in the range is unwrapped.
 */
declare const unwrapNodes: <E extends TEditor>(editor: E, options?: UnwrapNodesOptions<E>) => void;

type WrapNodesOptions<E extends TEditor = TEditor> = Modify<NonNullable<Parameters<typeof Transforms.wrapNodes>[2]>, NodeMatchOption<E>>;
/**
 * Wrap the nodes at a location in a new container node, splitting the edges of
 * the range first to ensure that only the content in the range is wrapped.
 */
declare const wrapNodes: <N extends ElementOf<E>, E extends TEditor = TEditor>(editor: E, element: N, options?: WrapNodesOptions<E>) => void;

type FindNodeOptions<E extends TEditor = TEditor> = GetNodeEntriesOptions<E>;
/** Find node matching the condition. */
declare const findNode: <N extends NodeOf<E>, E extends TEditor = TEditor>(editor: E, options?: FindNodeOptions<E>) => TNodeEntry<N> | undefined;

declare const findNodePath: <E extends TEditor = TEditor>(editor: E, node: TNode, options?: FindNodeOptions<E>) => slate.Path | undefined;

/**
 * Iterate through all of the nodes in the editor and break early for the first
 * truthy match. Otherwise returns false.
 */
declare const someNode: <N extends NodeOf<E>, E extends TEditor = TEditor>(editor: E, options: FindNodeOptions<E>) => boolean;

interface Batch {
    operations: Operation[];
    selectionBefore: Range | null;
}
/**
 * `History` objects hold all of the operations that are applied to a value, so
 * they can be undone or redone as necessary.
 */
interface History {
    redos: Batch[];
    undos: Batch[];
}
declare const History: {
    /** Check if a value is a `History` object. */
    isHistory(value: any): value is History;
};

/** Weakmaps for attaching state to the editor. */
declare const HISTORY: WeakMap<BaseEditor, History>;
declare const SAVING: WeakMap<BaseEditor, boolean | undefined>;
declare const MERGING: WeakMap<BaseEditor, boolean | undefined>;
declare const SPLITTING_ONCE: WeakMap<BaseEditor, boolean | undefined>;
/** `HistoryEditor` contains helpers for history-enabled editors. */
interface HistoryEditor extends BaseEditor {
    history: History;
    redo: () => void;
    undo: () => void;
    writeHistory: (stack: 'redos' | 'undos', batch: any) => void;
}
declare const HistoryEditor: {
    /** Check if a value is a `HistoryEditor` object. */
    isHistoryEditor(value: any): value is HistoryEditor;
    /** Get the merge flag's current value. */
    isMerging(editor: HistoryEditor): boolean | undefined;
    /** Get the splitting once flag's current value. */
    isSaving(editor: HistoryEditor): boolean | undefined;
    isSplittingOnce(editor: HistoryEditor): boolean | undefined;
    /** Get the saving flag's current value. */
    redo(editor: HistoryEditor): void;
    /** Redo to the previous saved state. */
    setSplittingOnce(editor: HistoryEditor, value: boolean | undefined): void;
    /** Undo to the previous saved state. */
    undo(editor: HistoryEditor): void;
    /**
     * Apply a series of changes inside a synchronous `fn`, These operations will
     * be merged into the previous history.
     */
    withMerging(editor: HistoryEditor, fn: () => void): void;
    /**
     * Apply a series of changes inside a synchronous `fn`, ensuring that the
     * first operation starts a new batch in the history. Subsequent operations
     * will be merged as usual.
     */
    withNewBatch(editor: HistoryEditor, fn: () => void): void;
    /**
     * Apply a series of changes inside a synchronous `fn`, without merging any of
     * the new operations into previous save point in the history.
     */
    withoutMerging(editor: HistoryEditor, fn: () => void): void;
    /**
     * Apply a series of changes inside a synchronous `fn`, without saving any of
     * their operations into the history.
     */
    withoutSaving(editor: HistoryEditor, fn: () => void): void;
};

/**
 * The `withHistory` plugin keeps track of the operation history of a Slate
 * editor as operations are applied to it, using undo and redo stacks.
 *
 * If you are using TypeScript, you must extend Slate's CustomTypes to use this
 * plugin.
 *
 * See https://docs.slatejs.org/concepts/11-typescript to learn how.
 */
declare const withHistory: <T extends Editor>(editor: T) => T & HistoryEditor;

/** Add marks to each node of a range. */
declare const addRangeMarks: (editor: TEditor, props: any, { at, }?: {
    at?: Location | null;
}) => void;

declare const setElements: (editor: TEditor, props: Partial<TNodeProps<TElement>>, options?: SetNodesOptions) => void;

declare const setNode: <N extends NodeOf<E>, E extends TEditor = TEditor>(editor: E, node: N, props: Partial<TNodeProps<N>>, options?: Omit<SetNodesOptions<E>, "at">) => void;

/** Unhang the range of length 1 so both edges are in the same text node. */
declare const unhangCharacterRange: (editor: TEditor, at: Range) => {
    anchor: slate.BasePoint;
    focus: slate.BasePoint;
};

/** Query the node entry. */
declare const queryNode: <N extends TNode>(entry?: TNodeEntry<N>, { allow, exclude, filter, level, maxLevel }?: QueryNodeOptions) => boolean;

export { type AncestorEntryOf, type AncestorOf, type ChildOf, type DescendantEntryOf, type DescendantOf, type ENodeMatch, type ENodeMatchOptions, type ElementEntryOf, type ElementOf, type ElementOrTextOf, type FindNodeOptions, type GetAboveNodeOptions, type GetLevelsOptions, type GetNextNodeOptions, type GetNodeEntriesOptions, type GetPreviousNodeOptions, HISTORY, History, HistoryEditor, type InsertNodesOptions, type LiftNodesOptions, MERGING, type MarkKeysOf, type MarksOf, type MergeNodesOptions, type MoveNodesOptions, type NodeEntryOf, type NodeMatchOption, type NodeOf, type NodeTextsOptions, type Predicate, type PredicateFn, type PredicateObj, type QueryEditorOptions, type QueryNodeOptions, type RemoveNodesOptions, SAVING, SPLITTING_ONCE, type SetNodesOptions, type SplitNodesOptions, type TAncestor, type TAncestorEntry, type TDecoratedRange, type TDescendant, type TDescendantEntry, type TEditor, type TElement, type TElementEntry, type TInsertNodeOperation, type TInsertTextOperation, type TLocation, type TMergeNodeOperation, type TMoveNodeOperation, type TNode, type TNodeChildEntry, type TNodeEntry, type TNodeMatch, type TNodeOperation, type TNodeProps, type TOperation, type TPath, type TRange, type TRemoveNodeOperation, type TRemoveTextOperation, type TSelection, type TSelectionOperation, type TSetNodeOperation, type TSetSelectionOperation, type TSpan, type TSplitNodeOperation, type TText, type TTextEntry, type TTextOperation, type TextEntryOf, type TextOf, type UnhangRangeOptions, type UnsetNodesOptions, type UnwrapNodesOptions, type Value, type ValueOf, type WrapNodesOptions, addMark, addRangeMarks, collapseSelection, createPathRef, createPointRef, createRangeRef, createTEditor, deleteBackward, deleteForward, deleteFragment, deleteMerge, deleteText, deselect, elementMatches, findNode, findNodePath, getAboveNode, getCommonNode, getEdgePoints, getEditorString, getEndPoint, getFirstNode, getFragment, getLastNode, getLeafNode, getLevels, getMarks, getNextNode, getNode, getNodeAncestor, getNodeAncestors, getNodeChild, getNodeChildren, getNodeDescendant, getNodeDescendants, getNodeElements, getNodeEntries, getNodeEntry, getNodeFirstNode, getNodeFragment, getNodeLastNode, getNodeLeaf, getNodeLevels, getNodeParent, getNodeProps, getNodeString, getNodeTexts, getNodes, getParentNode, getPath, getPathRefs, getPoint, getPointAfter, getPointBefore, getPointRefs, getPositions, getPreviousNode, getQueryOptions, getRange, getRangeRefs, getStartPoint, getVoidNode, hasBlocks, hasInlines, hasNode, hasSingleChild, hasTexts, insertBreak, insertFragment, insertNode, insertNodes, insertText, isAncestor, isBlock, isCollapsed, isDescendant, isEdgePoint, isEditor, isEditorNormalizing, isElement, isElementEmpty, isElementList, isEndPoint, isExpanded, isHistoryEditor, isHistoryMerging, isHistorySaving, isInline, isMarkableVoid, isNode, isNodeList, isStartPoint, isText, isTextList, isVoid, liftNodes, match, mergeNodes, moveNodes, moveSelection, nodeMatches, normalizeEditor, queryNode, removeEditorMark, removeNodes, select, setElements, setNode, setNodes, setPoint, setSelection, someNode, splitNodes, textEquals, textMatches, unhangCharacterRange, unhangRange, unsetNodes, unwrapNodes, withHistory, withMerging, withNewBatch, withoutMergingHistory, withoutNormalizing, withoutSavingHistory, wrapNodes };
